
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>anvil package &#8212; anvil  documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/classic.css" />
    
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/doctools.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">anvil  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">anvil package</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <section id="anvil-package">
<h1>anvil package<a class="headerlink" href="#anvil-package" title="Permalink to this headline">¶</a></h1>
<section id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="anvil.benchmark_config.html">anvil.benchmark_config package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="anvil.benchmark_config.html#module-anvil.benchmark_config">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="anvil.scripts.html">anvil.scripts package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="anvil.scripts.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="anvil.scripts.html#module-anvil.scripts.anvil_benchmark">anvil.scripts.anvil_benchmark module</a></li>
<li class="toctree-l2"><a class="reference internal" href="anvil.scripts.html#module-anvil.scripts.anvil_sample">anvil.scripts.anvil_sample module</a></li>
<li class="toctree-l2"><a class="reference internal" href="anvil.scripts.html#module-anvil.scripts.anvil_train">anvil.scripts.anvil_train module</a></li>
<li class="toctree-l2"><a class="reference internal" href="anvil.scripts.html#module-anvil.scripts">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="anvil.style.html">anvil.style package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="anvil.style.html#module-anvil.style">Module contents</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="anvil.tests.html">anvil.tests package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="anvil.tests.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="anvil.tests.html#module-anvil.tests.test_benchmark">anvil.tests.test_benchmark module</a></li>
<li class="toctree-l2"><a class="reference internal" href="anvil.tests.html#module-anvil.tests.test_distributions">anvil.tests.test_distributions module</a></li>
<li class="toctree-l2"><a class="reference internal" href="anvil.tests.html#anvil-tests-test-free-scalar-module">anvil.tests.test_free_scalar module</a></li>
<li class="toctree-l2"><a class="reference internal" href="anvil.tests.html#module-anvil.tests.test_geometry">anvil.tests.test_geometry module</a></li>
<li class="toctree-l2"><a class="reference internal" href="anvil.tests.html#anvil-tests-test-layers-module">anvil.tests.test_layers module</a></li>
<li class="toctree-l2"><a class="reference internal" href="anvil.tests.html#anvil-tests-test-learns-identity-module">anvil.tests.test_learns_identity module</a></li>
<li class="toctree-l2"><a class="reference internal" href="anvil.tests.html#anvil-tests-test-models-module">anvil.tests.test_models module</a></li>
<li class="toctree-l2"><a class="reference internal" href="anvil.tests.html#module-anvil.tests">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</section>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</section>
<section id="module-anvil.api">
<span id="anvil-api-module"></span><h2>anvil.api module<a class="headerlink" href="#module-anvil.api" title="Permalink to this headline">¶</a></h2>
<p>sample_api.py</p>
<p>This module contains the <code class="docutils literal notranslate"><span class="pre">reportengine</span></code> programmatic API, initialized with the
<code class="docutils literal notranslate"><span class="pre">anvil-sample</span></code> providers, Config and Environment.</p>
<section id="example">
<h3>Example:<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h3>
<p>In <code class="docutils literal notranslate"><span class="pre">anvil/examples/runcards</span></code> directory, run the training example:</p>
<blockquote>
<div><p>anvil-train train.yml</p>
</div></blockquote>
<p>Then you can use the API to access anvil-sample objects in a python environment.
For example in a python shell:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">anvil.api</span> <span class="kn">import</span> <span class="n">API</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">anvil.api</span> <span class="kn">import</span> <span class="n">API</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span> <span class="o">=</span> <span class="n">API</span><span class="o">.</span><span class="n">configs</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">training_output</span><span class="o">=</span><span class="s2">&quot;./train&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">cp_id</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">sample_size</span><span class="o">=</span><span class="mi">10000</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">thermalization</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">sample_interval</span><span class="o">=</span><span class="kc">None</span>
<span class="gp">... </span><span class="p">)</span>
<span class="go">configs: 100%|██████████████████████████| 10000/10000 [00:01&lt;00:00, 9152.14it/s]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sample</span><span class="o">.</span><span class="n">shape</span>
<span class="go">torch.Size([10000, 36])</span>
</pre></div>
</div>
<p>Of course this is not limited to use in a python shell, and can be used in
jupyter notebooks, scripts, tests etc.</p>
<p>The training class uses a config class which subclasses
<code class="docutils literal notranslate"><span class="pre">anvil.config.ConfigParser</span></code>, however most “intermediate” objects, required
for the training, can still be accessed:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">base</span> <span class="o">=</span> <span class="n">API</span><span class="o">.</span><span class="n">base_dist</span><span class="p">(</span><span class="n">base</span><span class="o">=</span><span class="s2">&quot;gaussian&quot;</span><span class="p">,</span> <span class="n">lattice_length</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span> <span class="n">lattice_dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">base</span><span class="p">)</span>
<span class="go">&lt;class &#39;anvil.distributions.Gaussian&#39;&gt;</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span> <span class="o">=</span> <span class="n">API</span><span class="o">.</span><span class="n">target_dist</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">target</span><span class="o">=</span><span class="s2">&quot;phi_four&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">lattice_length</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">lattice_dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">parameterisation</span><span class="o">=</span><span class="s2">&quot;standard&quot;</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">couplings</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;m_sq&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;g&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
<span class="gp">... </span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">type</span><span class="p">(</span><span class="n">target</span><span class="p">)</span>
<span class="go">&lt;class &#39;anvil.distributions.PhiFourScalar&#39;&gt;</span>
</pre></div>
</div>
<p>One can also abuse the API to monkey patch objects in, instead of obtaining
them from the resource builder. Although this functionality is largely untested,
so might produce strange results.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">anvil.api</span> <span class="kn">import</span> <span class="n">API</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fake_metro_sample</span> <span class="o">=</span> <span class="p">[[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">API</span><span class="o">.</span><span class="n">configs</span><span class="p">(</span><span class="n">_metropolis_hastings</span><span class="o">=</span><span class="n">fake_metro_sample</span><span class="p">)</span>
<span class="go">[0, 1, 2, 3, 4]</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">fake_metro_sample</span></code> has replaced the namespace object
<code class="docutils literal notranslate"><span class="pre">_metropolis_hastings</span></code> and as a result, removes the dependencies normally
associated with that object (such has a model, sample size etc.).</p>
</section>
</section>
<section id="module-anvil.benchmarks">
<span id="anvil-benchmarks-module"></span><h2>anvil.benchmarks module<a class="headerlink" href="#module-anvil.benchmarks" title="Permalink to this headline">¶</a></h2>
<p>benchmarks.py</p>
<p>Module containing benchmarking functions which compare a NVP trained on free
theory to theoretical values. Largely used to check that the anvil machinery
is working correctly.</p>
<p class="rubric">Notes</p>
<p>See the docstring for anvil.free_scalar.FreeScalarEigenmodes for an explanation
of the theoretical predictions and how to match them to quantities derived from
a sample of generated field configurations.</p>
<dl class="py function">
<dt class="sig sig-object py" id="anvil.benchmarks.eigvals_from_sample">
<span class="sig-prename descclassname"><span class="pre">anvil.benchmarks.</span></span><span class="sig-name descname"><span class="pre">eigvals_from_sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fourier_transform</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">training_geometry</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.benchmarks.eigvals_from_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a prediction for the eigenvalues of the kinetic operator.</p>
<p>The prediction is based on the sample variance of the field configurations in
Fourier space.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fourier_transform</strong> (<em>torch.Tensor</em>) – Sample of field configurations in Fourier space.</p></li>
<li><p><strong>training_geometry</strong> – Geometry object corresponding to the lattice.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An array of dimensions (L, L) containing the eigenvalues.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.benchmarks.fourier_transform">
<span class="sig-prename descclassname"><span class="pre">anvil.benchmarks.</span></span><span class="sig-name descname"><span class="pre">fourier_transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">configs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">training_geometry</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.benchmarks.fourier_transform" title="Permalink to this definition">¶</a></dt>
<dd><p>Takes the Fourier transform of a sample of field configurations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>configs</strong> (<em>torch.Tensor</em>) – A (hopefully decorrelated) sample of field configurations in the
split representation. Shape: (sample_size, lattice_size)</p></li>
<li><p><strong>training_geometry</strong> – The geometry object corresponding to the lattice.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The Fourier transform of the sample in the Cartesian representation.
Defined such that the momenta increase monotonically with the index
on each axis.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.benchmarks.free_scalar_theory">
<span class="sig-prename descclassname"><span class="pre">anvil.benchmarks.</span></span><span class="sig-name descname"><span class="pre">free_scalar_theory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">training_target_dist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">training_geometry</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.benchmarks.free_scalar_theory" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns instance of FreeScalarEigenmodes with specific mass and lattice size.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#anvil.free_scalar.FreeScalarEigenmodes" title="anvil.free_scalar.FreeScalarEigenmodes">anvil.free_scalar.FreeScalarEigenmodes</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.benchmarks.plot_kinetic_eigenvalues">
<span class="sig-prename descclassname"><span class="pre">anvil.benchmarks.</span></span><span class="sig-name descname"><span class="pre">plot_kinetic_eigenvalues</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eigvals_from_sample</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">free_scalar_theory</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.benchmarks.plot_kinetic_eigenvalues" title="Permalink to this definition">¶</a></dt>
<dd><p>Plot the eigenvalues of the kinetic operator inferred from the sample
of generated field configurations with the theoretical predictions based
on the free scalar theory.</p>
<p>The plot is a two-dimensional heatmap with the momentum monotonically
increasing, from maximum negative to maximum positive, from the top
left to the bottom right corners.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.benchmarks.table_kinetic_eigenvalues">
<span class="sig-prename descclassname"><span class="pre">anvil.benchmarks.</span></span><span class="sig-name descname"><span class="pre">table_kinetic_eigenvalues</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">eigvals_from_sample</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">free_scalar_theory</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.benchmarks.table_kinetic_eigenvalues" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare the eigenvalues of the kinetic operator inferrered from the
sample of generated configurations with the theoretical predictions based
on the free scalar theory.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.benchmarks.table_real_space_variance">
<span class="sig-prename descclassname"><span class="pre">anvil.benchmarks.</span></span><span class="sig-name descname"><span class="pre">table_real_space_variance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">configs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">free_scalar_theory</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.benchmarks.table_real_space_variance" title="Permalink to this definition">¶</a></dt>
<dd><p>Compare the sample variance of the generated configurations with the
theoretical prediction based on the free scalar theory.</p>
<p>Due to translational invariance, the field at each lattice site follows the
same Gaussian distribution. We therefore compare the lattice-average of the
sample variance with the theory prediction.</p>
</dd></dl>

</section>
<section id="module-anvil.checkpoint">
<span id="anvil-checkpoint-module"></span><h2>anvil.checkpoint module<a class="headerlink" href="#module-anvil.checkpoint" title="Permalink to this headline">¶</a></h2>
<p>checkpoint.py</p>
<p>Module for loading neural networks and checkpoints - ensuring a copy of model
is made so that we don’t get unexpected results</p>
<dl class="py class">
<dt class="sig sig-object py" id="anvil.checkpoint.Checkpoint">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">anvil.checkpoint.</span></span><span class="sig-name descname"><span class="pre">Checkpoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.checkpoint.Checkpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class which saves and loads checkpoints and allows checkpoints to be
sorted</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path</strong> (<em>str</em>) – </p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="anvil.checkpoint.Checkpoint.load">
<span class="sig-name descname"><span class="pre">load</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#anvil.checkpoint.Checkpoint.load" title="Permalink to this definition">¶</a></dt>
<dd><p>Return checkpoint dictionary</p>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="anvil.checkpoint.InvalidCheckpointError">
<em class="property"><span class="pre">exception</span> </em><span class="sig-prename descclassname"><span class="pre">anvil.checkpoint.</span></span><span class="sig-name descname"><span class="pre">InvalidCheckpointError</span></span><a class="headerlink" href="#anvil.checkpoint.InvalidCheckpointError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="anvil.checkpoint.InvalidTrainingOutputError">
<em class="property"><span class="pre">exception</span> </em><span class="sig-prename descclassname"><span class="pre">anvil.checkpoint.</span></span><span class="sig-name descname"><span class="pre">InvalidTrainingOutputError</span></span><a class="headerlink" href="#anvil.checkpoint.InvalidTrainingOutputError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="anvil.checkpoint.TrainingOutput">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">anvil.checkpoint.</span></span><span class="sig-name descname"><span class="pre">TrainingOutput</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.checkpoint.TrainingOutput" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class which acts as container for training output, which is a directory
containing training configuration, checkpoints and training logs</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path</strong> (<em>str</em>) – </p>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="anvil.checkpoint.TrainingOutput.as_input">
<span class="sig-name descname"><span class="pre">as_input</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#anvil.checkpoint.TrainingOutput.as_input" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.checkpoint.TrainingOutput.final_checkpoint">
<span class="sig-name descname"><span class="pre">final_checkpoint</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#anvil.checkpoint.TrainingOutput.final_checkpoint" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.checkpoint.TrainingOutput.get_config">
<span class="sig-name descname"><span class="pre">get_config</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#anvil.checkpoint.TrainingOutput.get_config" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="anvil.checkpoint.TrainingRuncardNotFound">
<em class="property"><span class="pre">exception</span> </em><span class="sig-prename descclassname"><span class="pre">anvil.checkpoint.</span></span><span class="sig-name descname"><span class="pre">TrainingRuncardNotFound</span></span><a class="headerlink" href="#anvil.checkpoint.TrainingRuncardNotFound" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#anvil.checkpoint.InvalidTrainingOutputError" title="anvil.checkpoint.InvalidTrainingOutputError"><code class="xref py py-class docutils literal notranslate"><span class="pre">anvil.checkpoint.InvalidTrainingOutputError</span></code></a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.checkpoint.current_loss">
<span class="sig-prename descclassname"><span class="pre">anvil.checkpoint.</span></span><span class="sig-name descname"><span class="pre">current_loss</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loaded_checkpoint</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.checkpoint.current_loss" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the current value of the loss function from a loaded checkpoint, or
<code class="docutils literal notranslate"><span class="pre">None</span></code> if no checkpoint is provided.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.checkpoint.loaded_checkpoint">
<span class="sig-prename descclassname"><span class="pre">anvil.checkpoint.</span></span><span class="sig-name descname"><span class="pre">loaded_checkpoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">checkpoint</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.checkpoint.loaded_checkpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a loaded checkpoint containing the state of a model.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.checkpoint.loaded_model">
<span class="sig-prename descclassname"><span class="pre">anvil.checkpoint.</span></span><span class="sig-name descname"><span class="pre">loaded_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loaded_checkpoint</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model_to_load</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.checkpoint.loaded_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads state from checkpoint if provided, returns instantiated model.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.checkpoint.loaded_optimizer">
<span class="sig-prename descclassname"><span class="pre">anvil.checkpoint.</span></span><span class="sig-name descname"><span class="pre">loaded_optimizer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loaded_model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loaded_checkpoint</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimizer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimizer_params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.checkpoint.loaded_optimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads state from checkpoint if provided, returns instantiated optimizer.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.checkpoint.loaded_scheduler">
<span class="sig-prename descclassname"><span class="pre">anvil.checkpoint.</span></span><span class="sig-name descname"><span class="pre">loaded_scheduler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loaded_optimizer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loaded_checkpoint</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scheduler</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scheduler_params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.checkpoint.loaded_scheduler" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads state from checkpoint if provided, returns instantiated scheduler.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.checkpoint.train_range">
<span class="sig-prename descclassname"><span class="pre">anvil.checkpoint.</span></span><span class="sig-name descname"><span class="pre">train_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loaded_checkpoint</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epochs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.checkpoint.train_range" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns tuple containing the indices of the next and last training iterations.</p>
<p>If training from scratch, this will look like <code class="docutils literal notranslate"><span class="pre">(0,</span> <span class="pre">epochs)</span></code> where <code class="docutils literal notranslate"><span class="pre">epochs</span></code>.
If loading from a checkpoint, it will instead look like <code class="docutils literal notranslate"><span class="pre">(i_cp,</span> <span class="pre">epochs)</span></code>
where <code class="docutils literal notranslate"><span class="pre">i_cp</span></code> indexes the iteration at which the checkpoint was saved.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>epochs</strong> (<em>int</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>tuple</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-anvil.checks">
<span id="anvil-checks-module"></span><h2>anvil.checks module<a class="headerlink" href="#module-anvil.checks" title="Permalink to this headline">¶</a></h2>
<p>checks.py</p>
<p>Module containing checks. Checks are performed at “compile time” and ensure
correct configuration is used before executing any actions</p>
<dl class="py function">
<dt class="sig sig-object py" id="anvil.checks.check_trained_with_free_theory">
<span class="sig-prename descclassname"><span class="pre">anvil.checks.</span></span><span class="sig-name descname"><span class="pre">check_trained_with_free_theory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">training_target_dist</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.checks.check_trained_with_free_theory" title="Permalink to this definition">¶</a></dt>
<dd><p>Check that supplied model is a free theory model which in the case of
phi^4 means that lambda = 0</p>
</dd></dl>

</section>
<section id="module-anvil.config">
<span id="anvil-config-module"></span><h2>anvil.config module<a class="headerlink" href="#module-anvil.config" title="Permalink to this headline">¶</a></h2>
<p>config.py</p>
<p>Module to parse runcards</p>
<dl class="py class">
<dt class="sig sig-object py" id="anvil.config.ConfigParser">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">anvil.config.</span></span><span class="sig-name descname"><span class="pre">ConfigParser</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">input_params</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">environment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">reportengine.report.Config</span></code></p>
<p>Extend the reportengine Config class for anvil-specific
objects</p>
<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.parse_bootstrap_sample_size">
<span class="sig-name descname"><span class="pre">parse_bootstrap_sample_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_boot</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.parse_bootstrap_sample_size" title="Permalink to this definition">¶</a></dt>
<dd><p>The size of the bootstrap sample.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n_boot</strong> (<em>int</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.parse_checkpoints">
<span class="sig-name descname"><span class="pre">parse_checkpoints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">training_output</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.parse_checkpoints" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of None objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>param</strong> (<em>list</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.parse_cosh_fit_min_separation">
<span class="sig-name descname"><span class="pre">parse_cosh_fit_min_separation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">training_geometry</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.parse_cosh_fit_min_separation" title="Permalink to this definition">¶</a></dt>
<dd><p>The smallest lattice separation to include in when fitting a cosh function
to the correlator, so as to the extract the correlation length.</p>
<p>See also: <code class="docutils literal notranslate"><span class="pre">produce_cosh_fit_window</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n</strong> (<em>int</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.parse_couplings">
<span class="sig-name descname"><span class="pre">parse_couplings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">couplings</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.parse_couplings" title="Permalink to this definition">¶</a></dt>
<dd><p>A dict containing the couplings for the target field theory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>couplings</strong> (<em>dict</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.parse_cp_id">
<span class="sig-name descname"><span class="pre">parse_cp_id</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cp</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.parse_cp_id" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cp</strong> (<em>(</em><em>&lt;class 'int'&gt;</em><em>, </em><em>&lt;class 'NoneType'&gt;</em><em>)</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(&lt;class ‘int’&gt;, None)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.parse_cp_ids">
<span class="sig-name descname"><span class="pre">parse_cp_ids</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.parse_cp_ids" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of cp_id objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>param</strong> (<em>list</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.parse_epochs">
<span class="sig-name descname"><span class="pre">parse_epochs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">epochs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.parse_epochs" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of training iterations, i.e. updates of the model parameters.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>epochs</strong> (<em>int</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.parse_lattice_dimension">
<span class="sig-name descname"><span class="pre">parse_lattice_dimension</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.parse_lattice_dimension" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of spatial dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>dim</strong> (<em>int</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.parse_lattice_length">
<span class="sig-name descname"><span class="pre">parse_lattice_length</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.parse_lattice_length" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of nodes along each spatial dimension.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>length</strong> (<em>int</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.parse_n_batch">
<span class="sig-name descname"><span class="pre">parse_n_batch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nb</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.parse_n_batch" title="Permalink to this definition">¶</a></dt>
<dd><p>Batch size for training.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>nb</strong> (<em>int</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.parse_optimizer">
<span class="sig-name descname"><span class="pre">parse_optimizer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">optimizer</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.parse_optimizer" title="Permalink to this definition">¶</a></dt>
<dd><p>A label for the optimization algorithm to use during training.</p>
<p>An optimizer is loaded using <code class="docutils literal notranslate"><span class="pre">getattr(torch.optim,</span> <span class="pre">&lt;optimizer&gt;)</span></code>. Therefore
this label must correspond to a <a class="reference external" href="https://pytorch.org/docs/stable/optim.html#algorithms">valid PyTorch optimizer</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>optimizer</strong> (<em>str</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.parse_optimizer_params">
<span class="sig-name descname"><span class="pre">parse_optimizer_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.parse_optimizer_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameters for the optimization algorithm.</p>
<p>Consult the documentation for <a class="reference external" href="https://pytorch.org/docs/stable/optim.html#algorithms">valid PyTorch optimizer</a> s.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>params</strong> (<em>dict</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.parse_parameterisation">
<span class="sig-name descname"><span class="pre">parse_parameterisation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.parse_parameterisation" title="Permalink to this definition">¶</a></dt>
<dd><p>A string defining the parameterisation used for the target theory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>param</strong> (<em>str</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.parse_sample_interval">
<span class="sig-name descname"><span class="pre">parse_sample_interval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">interval</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.parse_sample_interval" title="Permalink to this definition">¶</a></dt>
<dd><p>A number of Markov chain steps to discard between configurations that are
selected for the output sample.</p>
<p>Can be specified by the user in the runcard, or left to an automatic
calculation based on the acceptance rate of the Metropolis-Hastings algorith.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>interval</strong> (<em>(</em><em>&lt;class 'int'&gt;</em><em>, </em><em>&lt;class 'NoneType'&gt;</em><em>)</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(&lt;class ‘int’&gt;, &lt;class ‘NoneType’&gt;)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.parse_sample_size">
<span class="sig-name descname"><span class="pre">parse_sample_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.parse_sample_size" title="Permalink to this definition">¶</a></dt>
<dd><p>The number of configurations in the output sample.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>size</strong> (<em>int</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.parse_save_interval">
<span class="sig-name descname"><span class="pre">parse_save_interval</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">save_int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.parse_save_interval" title="Permalink to this definition">¶</a></dt>
<dd><p>A checkpoint containing the model state will be written every <code class="docutils literal notranslate"><span class="pre">save_interval</span></code>
training iterations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>save_int</strong> (<em>int</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.parse_scheduler">
<span class="sig-name descname"><span class="pre">parse_scheduler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scheduler</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.parse_scheduler" title="Permalink to this definition">¶</a></dt>
<dd><p>A label for the learning rate scheduler to use during training.</p>
<p>An scheduler is loaded using <code class="docutils literal notranslate"><span class="pre">getattr(torch.optim.lr_scheduler,</span> <span class="pre">&lt;optimizer&gt;)</span></code>.
Therefore this label must correspond a <a class="reference external" href="https://pytorch.org/docs/stable/optim.html#how-to-adjust-learning-rate">valid PyTorch scheduler</a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>scheduler</strong> (<em>str</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>str</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.parse_scheduler_params">
<span class="sig-name descname"><span class="pre">parse_scheduler_params</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.parse_scheduler_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameters for the learning rate scheduler.</p>
<p>Consult the documentation for <a class="reference external" href="https://pytorch.org/docs/stable/optim.html#how-to-adjust-learning-rate">valid PyTorch scheduler</a> s.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>params</strong> (<em>dict</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.parse_sigma">
<span class="sig-name descname"><span class="pre">parse_sigma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.parse_sigma" title="Permalink to this definition">¶</a></dt>
<dd><p>The standard deviation of a normal distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sigma</strong> (<em>float</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.parse_thermalization">
<span class="sig-name descname"><span class="pre">parse_thermalization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">therm</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.parse_thermalization" title="Permalink to this definition">¶</a></dt>
<dd><p>A number of Markov chain steps to be discarded before beginning to select
configurations for the output sample.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>therm</strong> (<em>(</em><em>&lt;class 'int'&gt;</em><em>, </em><em>&lt;class 'NoneType'&gt;</em><em>)</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>(&lt;class ‘int’&gt;, &lt;class ‘NoneType’&gt;)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.parse_training_output">
<span class="sig-name descname"><span class="pre">parse_training_output</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.parse_training_output" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a path to a training directory, returns an object that interfaces with
this directory.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>path</strong> (<em>str</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.parse_training_outputs">
<span class="sig-name descname"><span class="pre">parse_training_outputs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.parse_training_outputs" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of training_output objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>param</strong> (<em>list</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.parse_window">
<span class="sig-name descname"><span class="pre">parse_window</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">window</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.parse_window" title="Permalink to this definition">¶</a></dt>
<dd><p>A numerical factor featuring in the calculation of the optimal ‘window’
size, which is then used to measure the integrated autocorrelation time of
observables.</p>
<p>Suggested values are between 1 and 2. However, this should be judged by
checking that the integrated autocorrelation has approximately plateaued
at the optimal window size.</p>
<p>See <code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.observables.automatic_windowing_function()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>window</strong> (<em>float</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>float</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.parse_windows">
<span class="sig-name descname"><span class="pre">parse_windows</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">param</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.parse_windows" title="Permalink to this definition">¶</a></dt>
<dd><p>A list of window objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>param</strong> (<em>list</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.produce_base_dist">
<span class="sig-name descname"><span class="pre">produce_base_dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lattice_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.produce_base_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses arguments to instantiate <a class="reference internal" href="#anvil.distributions.Gaussian" title="anvil.distributions.Gaussian"><code class="xref py py-class docutils literal notranslate"><span class="pre">anvil.distributions.Gaussian</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loc</strong> (<em>(</em><em>&lt;class 'int'&gt;</em><em>, </em><em>&lt;class 'float'&gt;</em><em>)</em>) – </p></li>
<li><p><strong>sigma</strong> (<em>(</em><em>&lt;class 'int'&gt;</em><em>, </em><em>&lt;class 'float'&gt;</em><em>)</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#anvil.distributions.Gaussian" title="anvil.distributions.Gaussian">anvil.distributions.Gaussian</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.produce_bootstrap_seed">
<span class="sig-name descname"><span class="pre">produce_bootstrap_seed</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">manual_bootstrap_seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.produce_bootstrap_seed" title="Permalink to this definition">¶</a></dt>
<dd><p>Optional seed for the random number generator which generates the bootstrap
sample, for the purpose of reproducibility.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>manual_bootstrap_seed</strong> (<em>(</em><em>&lt;class 'int'&gt;</em><em>, </em><em>&lt;class 'NoneType'&gt;</em><em>)</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.produce_checkpoint">
<span class="sig-name descname"><span class="pre">produce_checkpoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cp_id</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">training_output</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.produce_checkpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Attempts to return a checkpoint object extracted from a training output.</p>
<ul class="simple">
<li><p>If <code class="docutils literal notranslate"><span class="pre">cp_id</span> <span class="pre">==</span> <span class="pre">None</span></code>, no checkpoint is returned.</p></li>
<li><p>If <code class="docutils literal notranslate"><span class="pre">cp_id</span> <span class="pre">==</span> <span class="pre">-1</span></code>, the checkpoint with the highest <code class="docutils literal notranslate"><span class="pre">cp_id</span></code> is returned.</p></li>
<li><p>Otherwise, attempts to load checkpoint with id <code class="docutils literal notranslate"><span class="pre">cp_id</span></code>.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>cp_id</strong> (<em>(</em><em>&lt;class 'int'&gt;</em><em>, </em><em>&lt;class 'NoneType'&gt;</em><em>)</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.produce_cosh_fit_window">
<span class="sig-name descname"><span class="pre">produce_cosh_fit_window</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">training_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cosh_fit_min_separation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.produce_cosh_fit_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Window of values corresponding to lattice separations, within which to fit
a cosh function to the correlator, so as to the extract the correlation length.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.produce_geometry">
<span class="sig-name descname"><span class="pre">produce_geometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lattice_length</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.produce_geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the geometry object defining the lattice.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>lattice_length</strong> (<em>int</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.produce_lattice_size">
<span class="sig-name descname"><span class="pre">produce_lattice_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lattice_length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lattice_dimension</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.produce_lattice_size" title="Permalink to this definition">¶</a></dt>
<dd><p>The total number of nodes on the lattice.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>lattice_length</strong> (<em>int</em>) – </p></li>
<li><p><strong>lattice_dimension</strong> (<em>int</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.produce_layer_action">
<span class="sig-name descname"><span class="pre">produce_layer_action</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">layer</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.produce_layer_action" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a string, returns the flow model action indexed by that string.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>layer</strong> (<em>str</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.produce_size_half">
<span class="sig-name descname"><span class="pre">produce_size_half</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lattice_size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.produce_size_half" title="Permalink to this definition">¶</a></dt>
<dd><p>Half of the number of nodes on the lattice.</p>
<p>This defines the size of the input layer to the neural networks.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>lattice_size</strong> (<em>int</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.produce_target_dist">
<span class="sig-name descname"><span class="pre">produce_target_dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parameterisation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">couplings</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.produce_target_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses arguments to instantiate <a class="reference internal" href="#anvil.distributions.PhiFourScalar" title="anvil.distributions.PhiFourScalar"><code class="xref py py-class docutils literal notranslate"><span class="pre">anvil.distributions.PhiFourScalar</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>parameterisation</strong> (<em>str</em>) – </p></li>
<li><p><strong>couplings</strong> (<em>dict</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.produce_training_base_dist">
<span class="sig-name descname"><span class="pre">produce_training_base_dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">training_context</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.produce_training_base_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces the base distribution object used in training.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>training_context</strong> (<em>dict</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.produce_training_context">
<span class="sig-name descname"><span class="pre">produce_training_context</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">training_output</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.produce_training_context" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a training output, produces the context of that training as a dict.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.produce_training_geometry">
<span class="sig-name descname"><span class="pre">produce_training_geometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">training_context</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.produce_training_geometry" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces the geometry object used in training.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>training_context</strong> (<em>dict</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.produce_training_target_dist">
<span class="sig-name descname"><span class="pre">produce_training_target_dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">training_context</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.produce_training_target_dist" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces the target distribution object used in training.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>training_context</strong> (<em>dict</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.config.ConfigParser.produce_use_multiprocessing">
<span class="sig-name descname"><span class="pre">produce_use_multiprocessing</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#anvil.config.ConfigParser.produce_use_multiprocessing" title="Permalink to this definition">¶</a></dt>
<dd><p>Don’t use Python multiprocessing on MacOS</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>bool</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-anvil.distributions">
<span id="anvil-distributions-module"></span><h2>anvil.distributions module<a class="headerlink" href="#module-anvil.distributions" title="Permalink to this headline">¶</a></h2>
<p>distributions.py</p>
<p>Module containing classes corresponding to different probability distributions.</p>
<dl class="py class">
<dt class="sig sig-object py" id="anvil.distributions.Gaussian">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">anvil.distributions.</span></span><span class="sig-name descname"><span class="pre">Gaussian</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size_out</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.distributions.Gaussian" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.distributions.normal.Normal</span></code></p>
<p>Class which handles the generation of a sample of latent Gaussian variables.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size_out</strong> (<em>int</em>) – Number of (independent) Gaussian numbers making up a ‘latent configuration’.</p></li>
<li><p><strong>loc</strong> (<em>float</em>) – Mean of the Gaussian distribution.</p></li>
<li><p><strong>scale</strong> (<em>float</em>) – Standard deviation of the Gaussian distribution.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="anvil.distributions.Gaussian.size_out">
<span class="sig-name descname"><span class="pre">size_out</span></span><a class="headerlink" href="#anvil.distributions.Gaussian.size_out" title="Permalink to this definition">¶</a></dt>
<dd><p>Number of (independent) Gaussian numbers making up a ‘latent configuration’.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.distributions.Gaussian.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample_size</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.distributions.Gaussian.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Return a sample of variables drawn from the normal distribution,
dimensions <code class="docutils literal notranslate"><span class="pre">(sample_size,</span> <span class="pre">self.size_out)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sample_size</strong> (<em>int</em>) – Number of latent configurations, each containing <code class="docutils literal notranslate"><span class="pre">self.size_out</span></code>
independent Gaussian numbers, in the sample</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Sample drawn from Gaussian distribution, dimensions
<code class="docutils literal notranslate"><span class="pre">(sample_size,</span> <span class="pre">self.size_out)</span></code>
Tensor containing logarithm of the probability density evaluated for
each latent configuration, dimensions <code class="docutils literal notranslate"><span class="pre">(sample_size,</span> <span class="pre">1)</span></code></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.distributions.Gaussian.log_density">
<span class="sig-name descname"><span class="pre">log_density</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sample</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.distributions.Gaussian.log_density" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the log probability for each latent configuration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sample</strong> (<em>torch.Tensor</em>) – Sample of Gaussian variables, dimensions <code class="docutils literal notranslate"><span class="pre">(sample_size,</span> <span class="pre">self.size_out)</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Tensor containing logarithm of the probability density evaluated for
each latent configuration, dimensions <code class="docutils literal notranslate"><span class="pre">(sample_size,</span> <span class="pre">1)</span></code></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="anvil.distributions.PhiFourScalar">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">anvil.distributions.</span></span><span class="sig-name descname"><span class="pre">PhiFourScalar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ising_coefficient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quadratic_coefficient</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">quartic_coefficient</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.distributions.PhiFourScalar" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class associated with the action for a scalar field theory with
<span class="math notranslate nohighlight">\(\phi^4\)</span> interaction.</p>
<p>methods to evaluate either the action or shifted log density on either a
single state - torch tensor, size <code class="docutils literal notranslate"><span class="pre">(1,</span> <span class="pre">length</span> <span class="pre">*</span> <span class="pre">length)</span></code> - or a stack of
<code class="docutils literal notranslate"><span class="pre">N</span></code> states - torch tensor, size <code class="docutils literal notranslate"><span class="pre">(N,</span> <span class="pre">length</span> <span class="pre">*</span> <span class="pre">length)</span></code>.
See Notes about action definition.</p>
<p>The parameters required differ depending on the parameterisation you’re
using:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 55%" />
<col style="width: 45%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>parameterisation</p></th>
<th class="head"><p>couplings</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>standard</p></td>
<td><p>m_sq, g</p></td>
</tr>
<tr class="row-odd"><td><p>albergo2019</p></td>
<td><p>m_sq, lam</p></td>
</tr>
<tr class="row-even"><td><p>nicoli2020</p></td>
<td><p>kappa, lam</p></td>
</tr>
<tr class="row-odd"><td><p>bosetti2015</p></td>
<td><p>beta, lam</p></td>
</tr>
</tbody>
</table>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>geometry</strong> – defines the geometry of the lattice, including dimension, size and
how the state is split into two parts</p></li>
<li><p><strong>parameterisation</strong> – which parameterisation to use. See below for options.</p></li>
<li><p><strong>couplings</strong> – dictionary with two entries that are the couplings of the theory.
See below.</p></li>
<li><p><strong>ising_coefficient</strong> (<em>float</em>) – </p></li>
<li><p><strong>quadratic_coefficient</strong> (<em>float</em>) – </p></li>
<li><p><strong>quartic_coefficient</strong> (<em>float</em>) – </p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The general form of the action is</p>
<div class="math notranslate nohighlight">
\[S(\phi) = \sum_{x \in \Lambda} \left[
    c_{\rm ising} * \sum_{\mu = 1}^d \phi(x + e_\mu) \phi(x) +
    c_{\rm quadratic} * \phi(x)^2 +
    c_{\rm quartic} * \phi(x)^4
\right]\]</div>
<p>where <span class="math notranslate nohighlight">\(c_{\rm ising}\)</span>, <span class="math notranslate nohighlight">\(c_{\rm quadratic}\)</span> and
<span class="math notranslate nohighlight">\(c_{\rm quartic}\)</span> are coefficients built from the two couplings
provided in the constructor, <span class="math notranslate nohighlight">\(\Lambda\)</span> is the space-time lattice
(the sum over the lattice is a sum over the lattice sites),
d is the number of space-time dimensions and
<span class="math notranslate nohighlight">\(e_\mu\)</span> is a unit vector in the <span class="math notranslate nohighlight">\(\mu^{th}\)</span> dimension.</p>
<p class="rubric">Examples</p>
<p>Consider the toy example of this class acting on a random state</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">anvil.geometry</span> <span class="kn">import</span> <span class="n">Geometry2D</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">anvil.distributions</span> <span class="kn">import</span> <span class="n">PhiFourScalar</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">torch</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry2D</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span> <span class="o">=</span> <span class="n">PhiFourScalar</span><span class="o">.</span><span class="n">from_standard</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="o">**</span><span class="p">{</span><span class="s2">&quot;m_sq&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;g&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">})</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span> <span class="c1"># 2-D so lattice cardinality is 4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span><span class="o">.</span><span class="n">log_density</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="go">tensor([[-2.3838]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">rand</span><span class="p">((</span><span class="mi">5</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target</span><span class="o">.</span><span class="n">log_density</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="go">tensor([[-3.9087],</span>
<span class="go">        [-2.2697],</span>
<span class="go">        [-2.3940],</span>
<span class="go">        [-2.3499],</span>
<span class="go">        [-1.9730]])</span>
</pre></div>
</div>
<dl class="py method">
<dt class="sig sig-object py" id="anvil.distributions.PhiFourScalar.action">
<span class="sig-name descname"><span class="pre">action</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phi</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.distributions.PhiFourScalar.action" title="Permalink to this definition">¶</a></dt>
<dd><p>Action computed for a sample of field configurations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>phi</strong> (<em>torch.Tensor</em>) – Tensor containing sample of configurations, dimensions
<code class="docutils literal notranslate"><span class="pre">(sample_size,</span> <span class="pre">lattice_size)</span></code></p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The computed action for each configuration in the sample, dimensions
<code class="docutils literal notranslate"><span class="pre">(sample_size,</span> <span class="pre">1)</span></code></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.distributions.PhiFourScalar.from_albergo2019">
<em class="property"><span class="pre">classmethod</span> </em><span class="sig-name descname"><span class="pre">from_albergo2019</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">geometry</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m_sq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.distributions.PhiFourScalar.from_albergo2019" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameterisation used in Albergo et al. (2019),
<a class="reference external" href="https://arxiv.org/abs/1904.12072">https://arxiv.org/abs/1904.12072</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m_sq</strong> (<em>float</em>) – Bare mass squared</p></li>
<li><p><strong>lam</strong> (<em>float</em>) – Quartic coupling constant</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.distributions.PhiFourScalar.from_bosetti2015">
<em class="property"><span class="pre">classmethod</span> </em><span class="sig-name descname"><span class="pre">from_bosetti2015</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">geometry</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">beta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.distributions.PhiFourScalar.from_bosetti2015" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameterisation used in Bosetti et al. (2015),
<a class="reference external" href="https://arxiv.org/abs/1506.08587">https://arxiv.org/abs/1506.08587</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>beta</strong> (<em>float</em>) – inverse temperature</p></li>
<li><p><strong>lam</strong> (<em>float</em>) – Quartic coupling constant</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.distributions.PhiFourScalar.from_nicoli2020">
<em class="property"><span class="pre">classmethod</span> </em><span class="sig-name descname"><span class="pre">from_nicoli2020</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">geometry</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kappa</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.distributions.PhiFourScalar.from_nicoli2020" title="Permalink to this definition">¶</a></dt>
<dd><p>Parameterisation used in Nicoli et al. (2020),
<a class="reference external" href="https://arxiv.org/abs/2007.07115">https://arxiv.org/abs/2007.07115</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m_sq</strong> – Bare mass squared</p></li>
<li><p><strong>lam</strong> (<em>float</em>) – Quartic coupling constant</p></li>
<li><p><strong>kappa</strong> (<em>float</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.distributions.PhiFourScalar.from_standard">
<em class="property"><span class="pre">classmethod</span> </em><span class="sig-name descname"><span class="pre">from_standard</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">geometry</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m_sq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">g</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.distributions.PhiFourScalar.from_standard" title="Permalink to this definition">¶</a></dt>
<dd><p>Standard parameterisation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m_sq</strong> (<em>float</em>) – Bare mass squared</p></li>
<li><p><strong>g</strong> (<em>float</em>) – Quartic coupling constant</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.distributions.PhiFourScalar.log_density">
<span class="sig-name descname"><span class="pre">log_density</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phi</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.distributions.PhiFourScalar.log_density" title="Permalink to this definition">¶</a></dt>
<dd><p>The negative action for a sample of field configurations.</p>
<p>This is equal to the logarithm of the probability density up to an constant
arising from unknown normalisation (the partition function).</p>
<p>See <a class="reference internal" href="#anvil.distributions.PhiFourScalar.action" title="anvil.distributions.PhiFourScalar.action"><code class="xref py py-mod docutils literal notranslate"><span class="pre">anvil.distributions.PhiFourScalar.action</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>phi</strong> (<em>torch.Tensor</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-anvil.free_scalar">
<span id="anvil-free-scalar-module"></span><h2>anvil.free_scalar module<a class="headerlink" href="#module-anvil.free_scalar" title="Permalink to this headline">¶</a></h2>
<p>free_scalar.py</p>
<p>module containing the FreeScalarEigenmodes class used to compare with model
trained to free scalar theory</p>
<dl class="py class">
<dt class="sig sig-object py" id="anvil.free_scalar.FreeScalarEigenmodes">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">anvil.free_scalar.</span></span><span class="sig-name descname"><span class="pre">FreeScalarEigenmodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m_sq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lattice_length</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.free_scalar.FreeScalarEigenmodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>The action for the theory of a free scalar on a lattice is</p>
<div class="math notranslate nohighlight">
\[S(\phi) = \frac{1}{2} \sum_x \sum_y \phi(x) K(x, y) \phi(y)\]</div>
<p>The eigenmodes of the matrix</p>
<p>(which is referred to here as the kinetic operator) are the momentum
states <span class="math notranslate nohighlight">\(\tilde\phi(p)\)</span>, and the associated eigenvalues in two dimensions
are</p>
<p>where (p1, p2) are the two components of p.</p>
<p>It can be shown that the action can be written in Fourier space as</p>
<p>and hence the partition function is a product of Gaussian distributions
for the variables <span class="math notranslate nohighlight">\(|\tilde\phi(p)|\)</span>, with variances</p>
<p>This means we can sample from this probability distribution in Fourier
space by simply generating Gaussian random numbers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>m_sq</strong> (<em>int</em>) – </p></li>
<li><p><strong>lattice_length</strong> (<em>int</em>) – </p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="anvil.free_scalar.FreeScalarEigenmodes.gen_complex_normal">
<em class="property"><span class="pre">static</span> </em><span class="sig-name descname"><span class="pre">gen_complex_normal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_sample</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">real</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.free_scalar.FreeScalarEigenmodes.gen_complex_normal" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a stack of complex arrays where real and imaginary components
are drawn from a Gaussian distribution with the same width.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_sample</strong> (<em>int</em>) – sample size</p></li>
<li><p><strong>sigma</strong> (<em>numpy.ndarray</em>) – array of standard deviations. Need not be one-dimensional</p></li>
<li><p><strong>real</strong> (<em>bool</em>) – (optional) flag. If True, the imaginary component is set to
zero, but a complex array is still returned.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>complex array of shape <code class="docutils literal notranslate"><span class="pre">(n_sample,</span> <span class="pre">*sigma.shape)</span></code></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.free_scalar.FreeScalarEigenmodes.gen_eigenmodes">
<span class="sig-name descname"><span class="pre">gen_eigenmodes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_sample</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.free_scalar.FreeScalarEigenmodes.gen_eigenmodes" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns sample of eigenmodes for the lattice free scalar theory.</p>
<p>The real and imaginary components of the eigenmodes are drawn from
Gaussian distributions with variances given by the eigenvalues of the
kinetic operator - see _variance() method above.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n_sample</strong> (<em>int</em>) – sample size</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>complex array of eigenmodes with shape <code class="docutils literal notranslate"><span class="pre">(n_sample,</span> <span class="pre">L,</span> <span class="pre">L)</span></code>
where L is the side length of the square lattice.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.free_scalar.FreeScalarEigenmodes.gen_real_space_fields">
<span class="sig-name descname"><span class="pre">gen_real_space_fields</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_sample</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.free_scalar.FreeScalarEigenmodes.gen_real_space_fields" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the inverse fourier transform of a sample of eigenmodes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>n_sample</strong> (<em>int</em>) – sample size</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>real array of real-space fields, with shape <code class="docutils literal notranslate"><span class="pre">(n_sample,</span> <span class="pre">L,</span> <span class="pre">L)</span></code>,
where L is the side-length of the square lattice.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-anvil.geometry">
<span id="anvil-geometry-module"></span><h2>anvil.geometry module<a class="headerlink" href="#module-anvil.geometry" title="Permalink to this headline">¶</a></h2>
<p>geometry.py</p>
<p>Module containing transformations related to geometry.</p>
<dl class="py class">
<dt class="sig sig-object py" id="anvil.geometry.Geometry2D">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">anvil.geometry.</span></span><span class="sig-name descname"><span class="pre">Geometry2D</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">length</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.geometry.Geometry2D" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Define the 2D geometry and the shifts in the two Cartesian
directions. The fields are stored in a one-dimensional array of size
length*length, assuming that the first Na entries correspond to the sites
that are updated by the affine transformation, and the remaining Nb
entries correspond to the sites that are left unchanged.</p>
<p><code class="docutils literal notranslate"><span class="pre">phi</span> <span class="pre">=</span> <span class="pre">|...</span> <span class="pre">phiA</span> <span class="pre">...|...</span> <span class="pre">phiB</span> <span class="pre">...|</span></code></p>
<p>using the notation in <a class="reference external" href="https://arxiv.org/pdf/2003.06413.pdf">https://arxiv.org/pdf/2003.06413.pdf</a> We call this
representation of the field a ‘split’ representation.</p>
<dl class="py method">
<dt class="sig sig-object py" id="anvil.geometry.Geometry2D.get_shift">
<span class="sig-name descname"><span class="pre">get_shift</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shifts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1,</span> <span class="pre">1)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">1)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.geometry.Geometry2D.get_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Provided with a set of <cite>shifts</cite> and <cite>dims</cite> which are tuples of equal
length N, the number of shifts. For the given system length used to
instance Geometry2D, which refers to size of a 2D state (length * length)
returns a tensor, size (N, length^2). Row i of the returned tensor indexes a
split state phi = (phiA, phiB) which has been shifted by shift[i] in
dimension dims[i]. The shifts are performed on the 2D cartesian states.</p>
<p>element i of shifts and dims can either both be an integer or both be a
tuple of equal length. In the case that the element is a tuple, it
represents multiple simultaneous shifts in multiple dimensions.</p>
<p>By default shifts = (1, 1) and dims = (0, 1) and the resulting tensor indexes
the nearest neighbours above and to the left respectively. This convention
is according to to torch.roll</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shifts</strong> (<em>tuple</em>) – a tuple of shifts to be applied. Each element represents a shift and can
either be an integer (if the shift is in a single dimension) or a tuple
if the shift is applied simultaneously in multiple dimensions (see
Examples).</p></li>
<li><p><strong>dims</strong> (<em>tuple</em>) – a tuple of dimensions to apply <cite>shifts</cite> to. As with shift, each element
in dim can itself be a tuple which indicates that multiple shifts will
be applied in multiple dimensions simultaneously. Note that
corresponding entries of dims and shifts must also match (either both
ints or both tuples of same length).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><p>Tensor which can be used to index split states such that</p>
<blockquote>
<div><p>state = tensor([phiA, phiB]),</p>
</div></blockquote>
<p>then state[shift] will return a 2xlength tensor:</p>
<blockquote>
<div><p>state[shift] -&gt; tensor([[neighbour right], [neighbour down]])</p>
</div></blockquote>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p>Consider the small example of 2x2 state:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">state_2d</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state_2d</span>
<span class="go">tensor([[0, 1],</span>
<span class="go">        [2, 3]])</span>
</pre></div>
</div>
<p>If we use a checkerboard pattern to split state into phiA and phiB
then phiA = [0, 3] and phiB = [1, 2]</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">phi</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">tensor</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry2D</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">shift</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">get_shift</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phi</span><span class="p">[</span><span class="n">shift</span><span class="p">]</span>
<span class="go">tensor([[2, 1, 3, 0],</span>
<span class="go">        [1, 2, 0, 3]])</span>
</pre></div>
</div>
<p>to see how multiple shifts works, consider the shift (1, 1) in dimensions
(0, 1): up one, left one</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">shift</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">get_shift</span><span class="p">(</span><span class="n">shifts</span><span class="o">=</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),),</span> <span class="n">dims</span><span class="o">=</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phi</span><span class="p">[</span><span class="n">shift</span><span class="p">]</span>
<span class="go">tensor([[3, 0, 2, 1]])</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>The conventions for how the shifts are applied are according the torch.roll
function, shift = +ve rolls the state in a direction that corresponds
to ascending index when using standard python indexing.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">torch.roll</span></code></dt><dd><p><a class="reference external" href="https://pytorch.org/docs/stable/torch.html#torch.roll">https://pytorch.org/docs/stable/torch.html#torch.roll</a></p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.geometry.Geometry2D.two_point_iterator">
<span class="sig-name descname"><span class="pre">two_point_iterator</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#anvil.geometry.Geometry2D.two_point_iterator" title="Permalink to this definition">¶</a></dt>
<dd><p>Generator which yields all the lattice shifts as one-dimensional tensors.</p>
<dl class="field-list simple">
<dt class="field-odd">Yields</dt>
<dd class="field-odd"><p><em>torch.Tensor</em> – one-dimensional tensor containing the shift indices for each lattice shift.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The order in which the shifts are generated is defined by the lexicographical
order of the Cartesian product of one-dimensional shifts. See <code class="xref py py-func docutils literal notranslate"><span class="pre">itertools.product()</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="py exception">
<dt class="sig sig-object py" id="anvil.geometry.ShiftsMismatchError">
<em class="property"><span class="pre">exception</span> </em><span class="sig-prename descclassname"><span class="pre">anvil.geometry.</span></span><span class="sig-name descname"><span class="pre">ShiftsMismatchError</span></span><a class="headerlink" href="#anvil.geometry.ShiftsMismatchError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
</dd></dl>

</section>
<section id="module-anvil.layers">
<span id="anvil-layers-module"></span><h2>anvil.layers module<a class="headerlink" href="#module-anvil.layers" title="Permalink to this headline">¶</a></h2>
<p>layers.py</p>
<p>Contains the transformations or “layers” which are the building blocks of
normalising flows. The layers are implemented using the PyTorch library, which
in practice means they subclass <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.nn.Module</span></code>. For more
information, check out the PyTorch
<a class="reference external" href="https://pytorch.org/docs/stable/generated/torch.nn.Module.html#torch.nn.Module">Module docs</a>.</p>
<p>The basic idea is of a flow is to generate a latent variable, in our framework
this would be using a class in <a class="reference internal" href="#module-anvil.distributions" title="anvil.distributions"><code class="xref py py-mod docutils literal notranslate"><span class="pre">anvil.distributions</span></code></a>. The latent
variables are then transformed by sequentially applying the transformation
layers. The key feature of the transformations is the ability to easily calculate
the Jacobian determinant. If the base density function is known, then we can
evaluate the model density exactly.</p>
<p>The bottom line is that we enforce a convention to the <code class="docutils literal notranslate"><span class="pre">forward</span></code> method
of each layer (a special method of <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.nn.Module</span></code> subclasses).
All layers in this module should contain a <code class="docutils literal notranslate"><span class="pre">forward</span></code> method which takes two
<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.Tensor</span></code> objects as inputs:</p>
<blockquote>
<div><ul class="simple">
<li><p>a batch of input configurations, dimensions <code class="docutils literal notranslate"><span class="pre">(batch</span> <span class="pre">size,</span> <span class="pre">lattice</span> <span class="pre">size)</span></code>.</p></li>
<li><p>a batch of scalars, dimensions <code class="docutils literal notranslate"><span class="pre">(batch</span> <span class="pre">size,</span> <span class="pre">1)</span></code>, that are the logarithm of the
‘current’ probability density, at this stage in the normalising flow.</p></li>
</ul>
</div></blockquote>
<p>Each transformation layers may contain several neural networks or learnable
parameters.</p>
<p>A full normalising flow, f, can be constructed from multiple layers using
function composition:</p>
<div class="math notranslate nohighlight">
\[f(z) = g_{N_{\rm layers}}( \ldots ( g_2( g_1( z ) ) ) \ldots )\]</div>
<p>As a matter of convenience we provide a subclass of
<code class="xref py py-class docutils literal notranslate"><span class="pre">torch.nn.Sequential</span></code>, which is initialised by passing multiple layers
as arguments (in the order in which the layers are applied). The main feature
of our version, <a class="reference internal" href="#anvil.layers.Sequential" title="anvil.layers.Sequential"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequential</span></code></a>, is that it conforms to our <code class="docutils literal notranslate"><span class="pre">forward</span></code>
convention. From the perspective of the user <a class="reference internal" href="#anvil.layers.Sequential" title="anvil.layers.Sequential"><code class="xref py py-class docutils literal notranslate"><span class="pre">Sequential</span></code></a> appears
as a single subclass of <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.nn.Module</span></code> which performs the
full normalising flow transformation <span class="math notranslate nohighlight">\(f(z)\)</span>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="anvil.layers.AdditiveLayer">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">anvil.layers.</span></span><span class="sig-name descname"><span class="pre">AdditiveLayer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size_half</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hidden_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">activation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z2_equivar</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">even_sites</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.layers.AdditiveLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#anvil.layers.CouplingLayer" title="anvil.layers.CouplingLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">anvil.layers.CouplingLayer</span></code></a></p>
<p>Class implementing additive coupling layers.</p>
<p>The additive transformation is given by</p>
<div class="math notranslate nohighlight">
\[C( v^A ; \mathbf{t}(v^P) ) = v^A - \mathbf{t}(v^P)\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{t}\)</span> is a neural network.</p>
<p>The transformation is volume-preserving, i.e.</p>
<div class="math notranslate nohighlight">
\[\log \det J = 0\]</div>
<p>Reference: <a class="reference external" href="https://arxiv.org/abs/1410.8516">https://arxiv.org/abs/1410.8516</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size_half</strong> (<em>int</em>) – </p></li>
<li><p><strong>hidden_shape</strong> (<em>(</em><em>&lt;class 'tuple'&gt;</em><em>, </em><em>&lt;class 'list'&gt;</em><em>)</em>) – </p></li>
<li><p><strong>activation</strong> (<em>str</em>) – </p></li>
<li><p><strong>z2_equivar</strong> (<em>bool</em>) – </p></li>
<li><p><strong>even_sites</strong> (<em>bool</em>) – </p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="anvil.layers.AdditiveLayer.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_density</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.layers.AdditiveLayer.forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Forward pass of affine transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v_in</strong> (<em>torch.Tensor</em>) – </p></li>
<li><p><strong>log_density</strong> (<em>torch.Tensor</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="anvil.layers.AdditiveLayer.training">
<span class="sig-name descname"><span class="pre">training</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#anvil.layers.AdditiveLayer.training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="anvil.layers.AffineLayer">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">anvil.layers.</span></span><span class="sig-name descname"><span class="pre">AffineLayer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size_half</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hidden_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">activation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z2_equivar</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">even_sites</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.layers.AffineLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#anvil.layers.CouplingLayer" title="anvil.layers.CouplingLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">anvil.layers.CouplingLayer</span></code></a></p>
<p>Class implementing affine coupling layers.</p>
<p>The affine transformation is given by</p>
<div class="math notranslate nohighlight">
\[C( v^A ; \mathbf{s}(v^P), \mathbf{t}(v^P) )
= ( v^A - \mathbf{t}(v^P) ) * \exp( -\mathbf{s}(v^P) )\]</div>
<p>The Jacobian determinant is</p>
<div class="math notranslate nohighlight">
\[\log \det J = - \sum_{x\in\Lambda^A} \mathbf{s}_x(v^P)\]</div>
<p>Reference: <a class="reference external" href="https://arxiv.org/abs/1605.08803">https://arxiv.org/abs/1605.08803</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size_half</strong> (<em>int</em>) – </p></li>
<li><p><strong>hidden_shape</strong> (<em>(</em><em>&lt;class 'tuple'&gt;</em><em>, </em><em>&lt;class 'list'&gt;</em><em>)</em>) – </p></li>
<li><p><strong>activation</strong> (<em>str</em>) – </p></li>
<li><p><strong>z2_equivar</strong> (<em>bool</em>) – </p></li>
<li><p><strong>even_sites</strong> (<em>bool</em>) – </p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="anvil.layers.AffineLayer.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_density</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.layers.AffineLayer.forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Forward pass of affine transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v_in</strong> (<em>torch.Tensor</em>) – </p></li>
<li><p><strong>log_density</strong> (<em>torch.Tensor</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="anvil.layers.AffineLayer.training">
<span class="sig-name descname"><span class="pre">training</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#anvil.layers.AffineLayer.training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="anvil.layers.BatchNormLayer">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">anvil.layers.</span></span><span class="sig-name descname"><span class="pre">BatchNormLayer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.layers.BatchNormLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.nn.modules.module.Module</span></code></p>
<p>Performs batch normalisation on the inputs, conforming to our <code class="docutils literal notranslate"><span class="pre">forward</span></code>
convention.</p>
<p>Inputs are standardised over all tensor dimensions such that the resulting sample
has null mean and unit variance, after which a rescaling factor is applied.</p>
<div class="math notranslate nohighlight">
\[v_{\rm out} = \gamma
    \frac{v_{\rm in} - \mathbb{E}[ v_{\rm in} ]}
    {\sqrt{\mathrm{var}( v_{\rm in} ) + \epsilon}}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>scale</strong> (<em>float</em>) – The multiplicative factor, <span class="math notranslate nohighlight">\(\gamma\)</span>, applied to the standardised data.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Applying batch normalisation before the first spline layer can be helpful for
ensuring that the inputs remain within the transformation interval. However,
this layer adds undesirable stochasticity which can impede optimisation. One
might consider replacing it with <a class="reference internal" href="#anvil.layers.GlobalRescaling" title="anvil.layers.GlobalRescaling"><code class="xref py py-class docutils literal notranslate"><span class="pre">anvil.layers.GlobalRescaling</span></code></a> using
a static scale parameter.</p>
<dl class="py method">
<dt class="sig sig-object py" id="anvil.layers.BatchNormLayer.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_density</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.layers.BatchNormLayer.forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Forward pass of the batch normalisation transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v_in</strong> (<em>torch.Tensor</em>) – </p></li>
<li><p><strong>log_density</strong> (<em>torch.Tensor</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="anvil.layers.BatchNormLayer.training">
<span class="sig-name descname"><span class="pre">training</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#anvil.layers.BatchNormLayer.training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="anvil.layers.CouplingLayer">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">anvil.layers.</span></span><span class="sig-name descname"><span class="pre">CouplingLayer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size_half</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">even_sites</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.layers.CouplingLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.nn.modules.module.Module</span></code></p>
<p>Base class for coupling layers, inheriting from py:class:<cite>torch.nn.Module</cite> but
redefining the <code class="docutils literal notranslate"><span class="pre">forward</span></code> method so that the Jacobian determinant of the layers
are accumulated alongside the activations.</p>
<p>A generic coupling layer takes the form</p>
<div class="math notranslate nohighlight">
\[\begin{split}v^P &amp; \leftarrow v^P \\
v^A &amp; \leftarrow C \left( v^A ; \{\mathbf{N}(v^P)\} \right)\end{split}\]</div>
<p>where the <span class="math notranslate nohighlight">\(|\Lambda|\)</span>-dimensional input configuration <span class="math notranslate nohighlight">\(v\)</span> has been split
into two partitions, labelled by <span class="math notranslate nohighlight">\(A\)</span> and <span class="math notranslate nohighlight">\(P\)</span> (active and passive).</p>
<p>Here, the paritions are split according to a checkerboard (even/odd) scheme, as
defined in <a class="reference internal" href="#anvil.geometry.Geometry2D" title="anvil.geometry.Geometry2D"><code class="xref py py-class docutils literal notranslate"><span class="pre">anvil.geometry.Geometry2D</span></code></a>.</p>
<p><span class="math notranslate nohighlight">\(\{\mathbf{N}(v^P)\}\)</span> is a set of functions of the passive partition that parameterise
the coupling layer. These functions are to be modelled by neural networks.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size_half</strong> (<em>int</em>) – Half of the configuration size, which is the size of the input vector
for the neural networks.</p></li>
<li><p><strong>even_sites</strong> (<em>bool</em>) – dictates which half of the data is transformed as a and b, since
successive affine transformations alternate which half of the data is
passed through neural networks.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="anvil.layers.CouplingLayer.training">
<span class="sig-name descname"><span class="pre">training</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#anvil.layers.CouplingLayer.training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="anvil.layers.GlobalAffineLayer">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">anvil.layers.</span></span><span class="sig-name descname"><span class="pre">GlobalAffineLayer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scale</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shift</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.layers.GlobalAffineLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.nn.modules.module.Module</span></code></p>
<p>Applies an affine transformation to every data point using a given scale and shift,
which are <em>not</em> learnable. Useful to shift the domain of a learned distribution. This is
done at the cost of a constant term in the logarithm of the Jacobian determinant, which
is ignored.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scale</strong> (<em>(</em><em>int</em><em>, </em><em>float</em><em>)</em>) – Every data point will be multiplied by this factor.</p></li>
<li><p><strong>shift</strong> (<em>(</em><em>int</em><em>, </em><em>float</em><em>)</em>) – Every scaled data point will be shifted by this factor.</p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="anvil.layers.GlobalAffineLayer.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_density</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.layers.GlobalAffineLayer.forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Forward pass of the global affine transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v_in</strong> (<em>torch.Tensor</em>) – </p></li>
<li><p><strong>log_density</strong> (<em>torch.Tensor</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="anvil.layers.GlobalAffineLayer.training">
<span class="sig-name descname"><span class="pre">training</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#anvil.layers.GlobalAffineLayer.training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="anvil.layers.GlobalRescaling">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">anvil.layers.</span></span><span class="sig-name descname"><span class="pre">GlobalRescaling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learnable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.layers.GlobalRescaling" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.nn.modules.module.Module</span></code></p>
<p>Performs a global rescaling of the inputs via a (potentially learnable)
multiplicative factor, conforming to our <code class="docutils literal notranslate"><span class="pre">forward</span></code> convention.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scale</strong> (<em>float</em>) – The multiplicative factor applied to the inputs.</p></li>
<li><p><strong>learnable</strong> (<em>bool</em>) – If True, <code class="docutils literal notranslate"><span class="pre">scale</span></code> will be optimised during the training.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Applying a rescaling layer with a learnable <code class="docutils literal notranslate"><span class="pre">scale</span></code> to the final layer of a
normalizing flow can be useful since it avoids the need to tune earlier layers
to match the width of the target density. However, for best performance one
should generally use a static <code class="docutils literal notranslate"><span class="pre">scale</span></code> to reduce stochasticity in the
optimisation.</p>
<dl class="py method">
<dt class="sig sig-object py" id="anvil.layers.GlobalRescaling.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_density</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.layers.GlobalRescaling.forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Forward pass of the global rescaling layer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v_in</strong> (<em>torch.Tensor</em>) – </p></li>
<li><p><strong>log_density</strong> (<em>torch.Tensor</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="anvil.layers.GlobalRescaling.training">
<span class="sig-name descname"><span class="pre">training</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#anvil.layers.GlobalRescaling.training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="anvil.layers.RationalQuadraticSplineLayer">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">anvil.layers.</span></span><span class="sig-name descname"><span class="pre">RationalQuadraticSplineLayer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size_half</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interval</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_segments</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hidden_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">activation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z2_equivar</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">even_sites</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.layers.RationalQuadraticSplineLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#anvil.layers.CouplingLayer" title="anvil.layers.CouplingLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">anvil.layers.CouplingLayer</span></code></a></p>
<p>Class implementing rational quadratic spline coupling layers.</p>
<p>The transformation maps a finite interval <span class="math notranslate nohighlight">\([-a, a]\)</span> to itself and is defined
by a piecewise rational quadratic spline function, with the pieces joined up at ‘knots’.</p>
<p>The interval is divided into <span class="math notranslate nohighlight">\(K\)</span> bins with widths <span class="math notranslate nohighlight">\(w^k\)</span> and heights
<span class="math notranslate nohighlight">\(\mathbf{h}^k\)</span>. In addition to the widths and heights, the derivatives
<span class="math notranslate nohighlight">\(\mathbf{d}^k\)</span> at the internal knots are generated by a neural network.
<span class="math notranslate nohighlight">\(\mathbf{d}^0\)</span> and <span class="math notranslate nohighlight">\(\mathbf{d}^K\)</span> are set to unity.</p>
<p>Define the slopes connecting knots</p>
<div class="math notranslate nohighlight">
\[\mathbf{s}_i^k = \frac{\mathbf{h}_i^k}{\mathbf{w}_i^k}\]</div>
<p>and fractional position of the input <span class="math notranslate nohighlight">\(v_{i,x}\)</span> in the <span class="math notranslate nohighlight">\(\ell\)</span> -th bin</p>
<div class="math notranslate nohighlight">
\[\frac{(v_{i,x} - v_{i,x}^{\ell-1})}{\mathbf{w}_{i,x}^\ell}
\equiv \alpha_{i,x} \in [0, 1]\]</div>
<p>Then, the transformation is given by</p>
<div class="math notranslate nohighlight">
\[C_{i,x} ( v_{i, x} ; \mathbf{N}_{i, x}) = -a + \sum_{k=1}^{\ell-1} \mathbf{h}_{i,x}^k
+ \frac{ \mathbf{h}_{i, x}^\ell
\left[ \mathbf{s}_{i,x}^\ell \alpha_{i,x}^2
+ \mathbf{d}_{i,x}^{\ell-1} \alpha_{i,x} (1 - \alpha_{i,x}) \right] }
{\mathbf{s}_{i,x}^\ell + (\mathbf{d}_{i,x}^{\ell-1}
+ \mathbf{d}_{i,x}^\ell - 2 \mathbf{s}_{i,x}^\ell) \alpha_{i,x}(1 - \alpha_{i,x})}\]</div>
<p>The gradient is</p>
<div class="math notranslate nohighlight">
\[\frac{1}{\mathbf{w}_{i,x}^\ell} \frac{d C_{i, x}}{d\alpha_{i,x}}
= \frac{ (\mathbf{s}_{i,x}^\ell)^2 \left[
\mathbf{d}_{i,x}^\ell \alpha_{i,x}^2 + 2\mathbf{s}_{i,x}^\ell
\alpha_{i,x}(1 - \alpha_{i,x})
+ \mathbf{d}_{i,x}^{\ell-1} (1 - \alpha_{i,x})^2 \right]}
{\left[ \mathbf{s}_{i,x}^\ell
+ (\mathbf{d}_{i,x}^{\ell-1} + \mathbf{d}_{i,x}^\ell - 2\mathbf{s}_{i,x}^\ell
\alpha_{i,x} (1 - \alpha_{i,x}) \right]^2}\]</div>
<p>To obtain the logarithm of the Jacobian determinant we first take the logarithm and
then sum over <span class="math notranslate nohighlight">\(x\in\Lambda^A\)</span> .</p>
<p>Reference: <a class="reference external" href="https://arxiv.org/abs/1906.04032">https://arxiv.org/abs/1906.04032</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size_half</strong> (<em>int</em>) – </p></li>
<li><p><strong>interval</strong> (<em>int</em>) – </p></li>
<li><p><strong>n_segments</strong> (<em>int</em>) – </p></li>
<li><p><strong>hidden_shape</strong> (<em>(</em><em>&lt;class 'tuple'&gt;</em><em>, </em><em>&lt;class 'list'&gt;</em><em>)</em>) – </p></li>
<li><p><strong>activation</strong> (<em>str</em>) – </p></li>
<li><p><strong>z2_equivar</strong> (<em>bool</em>) – </p></li>
<li><p><strong>even_sites</strong> (<em>bool</em>) – </p></li>
</ul>
</dd>
</dl>
<dl class="py method">
<dt class="sig sig-object py" id="anvil.layers.RationalQuadraticSplineLayer.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_density</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">negative_mag</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.layers.RationalQuadraticSplineLayer.forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Forward pass of the rational quadratic spline layer.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v_in</strong> (<em>torch.Tensor</em>) – </p></li>
<li><p><strong>log_density</strong> (<em>torch.Tensor</em>) – </p></li>
<li><p><strong>negative_mag</strong> (<em>torch.Tensor</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="anvil.layers.RationalQuadraticSplineLayer.training">
<span class="sig-name descname"><span class="pre">training</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#anvil.layers.RationalQuadraticSplineLayer.training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="anvil.layers.Sequential">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">anvil.layers.</span></span><span class="sig-name descname"><span class="pre">Sequential</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.layers.Sequential" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.nn.modules.container.Sequential</span></code></p>
<p>Similar to <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.nn.Sequential</span></code> except conforms to our
<code class="docutils literal notranslate"><span class="pre">forward</span></code> convention.</p>
<dl class="py method">
<dt class="sig sig-object py" id="anvil.layers.Sequential.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">log_density</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.layers.Sequential.forward" title="Permalink to this definition">¶</a></dt>
<dd><p>overrides the base class <code class="docutils literal notranslate"><span class="pre">forward</span></code> method to conform to our
conventioned for expected inputs/outputs of <code class="docutils literal notranslate"><span class="pre">forward</span></code> methods.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v</strong> (<em>torch.Tensor</em>) – </p></li>
<li><p><strong>log_density</strong> (<em>torch.Tensor</em>) – </p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="anvil.layers.Sequential.training">
<span class="sig-name descname"><span class="pre">training</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#anvil.layers.Sequential.training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-anvil.models">
<span id="anvil-models-module"></span><h2>anvil.models module<a class="headerlink" href="#module-anvil.models" title="Permalink to this headline">¶</a></h2>
<p>models.py</p>
<p>Module containing reportengine actions which return normalising flow models.
Generally this involves piecing together components from <a class="reference internal" href="#module-anvil.layers" title="anvil.layers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">anvil.layers</span></code></a>
to produce sequences of transformations.</p>
<dl class="py function">
<dt class="sig sig-object py" id="anvil.models.batch_norm">
<span class="sig-prename descclassname"><span class="pre">anvil.models.</span></span><span class="sig-name descname"><span class="pre">batch_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.models.batch_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Action which returns an instance of <a class="reference internal" href="#anvil.layers.BatchNormLayer" title="anvil.layers.BatchNormLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">anvil.layers.BatchNormLayer</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>scale</strong> (<em>(</em><em>&lt;class 'int'&gt;</em><em>, </em><em>&lt;class 'float'&gt;</em><em>)</em>) – The multiplicative factor applied to the standardised data.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An instance of <a class="reference internal" href="#anvil.layers.BatchNormLayer" title="anvil.layers.BatchNormLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">anvil.layers.BatchNormLayer</span></code></a> wrapped by
<a class="reference internal" href="#anvil.layers.Sequential" title="anvil.layers.Sequential"><code class="xref py py-class docutils literal notranslate"><span class="pre">anvil.layers.Sequential</span></code></a> , which is simply there to make
iterating over layers easier and has no effect on the transformation
applied to the layer inputs.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#anvil.layers.Sequential" title="anvil.layers.Sequential">anvil.layers.Sequential</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.models.explicit_model">
<span class="sig-prename descclassname"><span class="pre">anvil.models.</span></span><span class="sig-name descname"><span class="pre">explicit_model</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">_api_normalizing_flow</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.models.explicit_model" title="Permalink to this definition">¶</a></dt>
<dd><p>Action to be called from the API. Build model from an explicit
specification, with same input as a training runcard config.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span> <span class="nn">anvil.api</span> <span class="kn">import</span> <span class="n">API</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">model_spec</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">... </span>    <span class="s2">&quot;model&quot;</span><span class="p">:</span> <span class="p">[</span>
<span class="gp">... </span>        <span class="p">{</span><span class="s2">&quot;layer&quot;</span><span class="p">:</span> <span class="s2">&quot;global_rescaling&quot;</span><span class="p">,</span> <span class="s2">&quot;scale&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">},</span>
<span class="gp">... </span>        <span class="p">{</span><span class="s2">&quot;layer&quot;</span><span class="p">:</span> <span class="s2">&quot;global_rescaling&quot;</span><span class="p">,</span> <span class="s2">&quot;scale&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">},</span>
<span class="gp">... </span>    <span class="p">]</span>
<span class="gp">... </span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">API</span><span class="o">.</span><span class="n">explicit_model</span><span class="p">(</span><span class="o">**</span><span class="n">model_spec</span><span class="p">)</span>
<span class="go">Sequential(</span>
<span class="go">  (0): GlobalRescaling()</span>
<span class="go">  (1): GlobalRescaling()</span>
<span class="go">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.models.global_rescaling">
<span class="sig-prename descclassname"><span class="pre">anvil.models.</span></span><span class="sig-name descname"><span class="pre">global_rescaling</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scale</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">learnable</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.models.global_rescaling" title="Permalink to this definition">¶</a></dt>
<dd><p>Action which returns and instance of <a class="reference internal" href="#anvil.layers.GlobalRescaling" title="anvil.layers.GlobalRescaling"><code class="xref py py-class docutils literal notranslate"><span class="pre">anvil.layers.GlobalRescaling</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scale</strong> (<em>(</em><em>&lt;class 'int'&gt;</em><em>, </em><em>&lt;class 'float'&gt;</em><em>)</em>) – The multiplicative factor applied to the inputs.</p></li>
<li><p><strong>learnable</strong> (<em>bool</em>) – If True, <code class="docutils literal notranslate"><span class="pre">scale</span></code> will be optimised during the training.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>An instance of <a class="reference internal" href="#anvil.layers.GlobalRescaling" title="anvil.layers.GlobalRescaling"><code class="xref py py-class docutils literal notranslate"><span class="pre">anvil.layers.GlobalRescaling</span></code></a> wrapped by
<a class="reference internal" href="#anvil.layers.Sequential" title="anvil.layers.Sequential"><code class="xref py py-class docutils literal notranslate"><span class="pre">anvil.layers.Sequential</span></code></a> , which is simply there to make
iterating over layers easier and has no effect on the transformation
applied to the layer inputs.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#anvil.layers.Sequential" title="anvil.layers.Sequential">anvil.layers.Sequential</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.models.model_to_load">
<span class="sig-prename descclassname"><span class="pre">anvil.models.</span></span><span class="sig-name descname"><span class="pre">model_to_load</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">_normalizing_flow</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.models.model_to_load" title="Permalink to this definition">¶</a></dt>
<dd><p>action which wraps a list of layers in
<a class="reference internal" href="#anvil.layers.Sequential" title="anvil.layers.Sequential"><code class="xref py py-class docutils literal notranslate"><span class="pre">anvil.layers.Sequential</span></code></a>. This allows the user to specify an
arbitrary combination of layers as the model.</p>
<p>For more information on valid choices for layers, see
<code class="docutils literal notranslate"><span class="pre">anvil.models.LAYER_OPTIONS</span></code> or the various
functions in <a class="reference internal" href="#module-anvil.models" title="anvil.models"><code class="xref py py-mod docutils literal notranslate"><span class="pre">anvil.models</span></code></a> which produce sequences of the layers
found in <a class="reference internal" href="#module-anvil.layers" title="anvil.layers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">anvil.layers</span></code></a>.</p>
<p>At present, available transformations are:</p>
<blockquote>
<div><ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">nice</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">real_nvp</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">rational_quadratic_spline</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">batch_norm</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">global_rescaling</span></code></p></li>
</ul>
</div></blockquote>
<p>You can see their dependencies using the <code class="docutils literal notranslate"><span class="pre">anvil</span></code> provider help, e.g.
for <code class="docutils literal notranslate"><span class="pre">real_nvp</span></code>:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>$ anvil-sample --help real_nvp
...
&lt; action docstring - poorly formatted&gt;
...
The following resources are read from the configuration:

    lattice_length(int):
[Used by lattice_size]

    lattice_dimension(int): Parse lattice dimension from runcard
[Used by lattice_size]

The following additionl arguments can be used to control the
behaviour. They are set by default to sensible values:

n_blocks
hidden_shape
activation = tanh
z2_equivar = True
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">anvil-train</span></code> will also provide the same information.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#anvil.layers.Sequential" title="anvil.layers.Sequential">anvil.layers.Sequential</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.models.nice">
<span class="sig-prename descclassname"><span class="pre">anvil.models.</span></span><span class="sig-name descname"><span class="pre">nice</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size_half</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_blocks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hidden_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">activation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'tanh'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z2_equivar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.models.nice" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to <a class="reference internal" href="#anvil.models.real_nvp" title="anvil.models.real_nvp"><code class="xref py py-func docutils literal notranslate"><span class="pre">real_nvp()</span></code></a>, excepts instead wraps pairs of
<a class="reference internal" href="#anvil.layers.AdditiveLayer" title="anvil.layers.AdditiveLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">anvil.layers.AdditiveLayer</span></code></a> .
The pairs of <code class="docutils literal notranslate"><span class="pre">AdditiveLayer</span></code> s act on the even and odd sites respectively.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size_half</strong> (<em>int</em>) – Inferred from <code class="docutils literal notranslate"><span class="pre">lattice_size</span></code>, the size of the active/passive
partitions (which are equal size, <cite>lattice_size / 2</cite>).</p></li>
<li><p><strong>n_blocks</strong> (<em>int</em>) – The number of pairs of <a class="reference internal" href="#anvil.layers.AffineLayer" title="anvil.layers.AffineLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">anvil.layers.AffineLayer</span></code></a>
transformations.</p></li>
<li><p><strong>hidden_shape</strong> (<em>(</em><em>&lt;class 'tuple'&gt;</em><em>, </em><em>&lt;class 'list'&gt;</em><em>)</em>) – the shape of the neural networks used in the each layer. The visible
layers are defined by the <code class="docutils literal notranslate"><span class="pre">lattice_size</span></code>.</p></li>
<li><p><strong>activation</strong> (<em>str</em>) – The activation function to use for each hidden layer. The output layer
of the network is linear (has no activation function).</p></li>
<li><p><strong>z2_equivar</strong> (<em>bool</em>) – Whether or not to impose z2 equivariance. This changes the transformation
such that the neural networks have no bias term and s(-v) = s(v) which
imposes a <span class="math notranslate nohighlight">\(\mathbb{Z}_2\)</span> symmetry.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A sequence of additive transformations, which we refer to as a
nice flow.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#anvil.layers.Sequential" title="anvil.layers.Sequential">anvil.layers.Sequential</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.models.rational_quadratic_spline">
<span class="sig-prename descclassname"><span class="pre">anvil.models.</span></span><span class="sig-name descname"><span class="pre">rational_quadratic_spline</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size_half</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_blocks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hidden_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_segments</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">interval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">activation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'tanh'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z2_equivar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.models.rational_quadratic_spline" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to <a class="reference internal" href="#anvil.models.real_nvp" title="anvil.models.real_nvp"><code class="xref py py-func docutils literal notranslate"><span class="pre">real_nvp()</span></code></a>, excepts instead wraps pairs of
<a class="reference internal" href="#anvil.layers.RationalQuadraticSplineLayer" title="anvil.layers.RationalQuadraticSplineLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">anvil.layers.RationalQuadraticSplineLayer</span></code></a> s.
The pairs of RQS’s act on the even and odd sites respectively.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size_half</strong> (<em>int</em>) – inferred from <code class="docutils literal notranslate"><span class="pre">lattice_size</span></code>, the size of the active/passive
partitions (which are equal size, <cite>lattice_size / 2</cite>).</p></li>
<li><p><strong>n_blocks</strong> (<em>int</em>) – The number of pairs of <a class="reference internal" href="#anvil.layers.AffineLayer" title="anvil.layers.AffineLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">anvil.layers.AffineLayer</span></code></a>
transformations. For RQS this is set to 1.</p></li>
<li><p><strong>hidden_shape</strong> (<em>(</em><em>&lt;class 'tuple'&gt;</em><em>, </em><em>&lt;class 'list'&gt;</em><em>)</em>) – the shape of the neural networks used in the each layer. The visible
layers are defined by the <code class="docutils literal notranslate"><span class="pre">lattice_size</span></code>.</p></li>
<li><p><strong>n_segments</strong> (<em>int</em>) – The number of segments to use in the RQS transformation.</p></li>
<li><p><strong>interval</strong> (<em>(</em><em>&lt;class 'int'&gt;</em><em>, </em><em>&lt;class 'float'&gt;</em><em>)</em>) – an integer <span class="math notranslate nohighlight">\(a\)</span> denoting a symmetric interval <span class="math notranslate nohighlight">\([-a, a]\)</span>
within which the RQS applies the transformation. At present, if a
field variable is outside of this region it is mapped to itself
(i.e the gradient of the transformation is 1 outside of the interval).</p></li>
<li><p><strong>activation</strong> (<em>str</em>) – The activation function to use for each hidden layer. The output layer
of the network is linear (has no activation function).</p></li>
<li><p><strong>z2_equivar</strong> (<em>bool</em>) – Whether or not to impose z2 equivariance. This is only done crudely
by splitting the sites according to the sign of the sum across lattice
sites.</p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference internal" href="#anvil.layers.Sequential" title="anvil.layers.Sequential">anvil.layers.Sequential</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.models.real_nvp">
<span class="sig-prename descclassname"><span class="pre">anvil.models.</span></span><span class="sig-name descname"><span class="pre">real_nvp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size_half</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_blocks</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hidden_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">activation</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'tanh'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z2_equivar</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.models.real_nvp" title="Permalink to this definition">¶</a></dt>
<dd><p>Action which returns a sequence of <code class="docutils literal notranslate"><span class="pre">n_blocks</span></code> pairs of
<a class="reference internal" href="#anvil.layers.AffineLayer" title="anvil.layers.AffineLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">anvil.layers.AffineLayer</span></code></a> s, wrapped in the module container
:py:class`anvil.layers.Sequential`.</p>
<p>The first <code class="docutils literal notranslate"><span class="pre">n_blocks</span></code> elements of the outer <code class="docutils literal notranslate"><span class="pre">Sequential</span></code>
are <code class="docutils literal notranslate"><span class="pre">Sequential</span></code> s containing a pair of <code class="docutils literal notranslate"><span class="pre">AffineLayer</span></code> s which
act on the even and odd sites respectively.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size_half</strong> (<em>int</em>) – Inferred from <code class="docutils literal notranslate"><span class="pre">lattice_size</span></code>, the size of the active/passive
partitions (which are equal size, <cite>lattice_size / 2</cite>).</p></li>
<li><p><strong>n_blocks</strong> (<em>int</em>) – The number of pairs of <a class="reference internal" href="#anvil.layers.AffineLayer" title="anvil.layers.AffineLayer"><code class="xref py py-class docutils literal notranslate"><span class="pre">anvil.layers.AffineLayer</span></code></a>
transformations.</p></li>
<li><p><strong>hidden_shape</strong> (<em>(</em><em>&lt;class 'tuple'&gt;</em><em>, </em><em>&lt;class 'list'&gt;</em><em>)</em>) – the shape of the neural networks used in the AffineLayer. The visible
layers are defined by the <code class="docutils literal notranslate"><span class="pre">lattice_size</span></code>. Typically we have found
a single hidden layer neural network is effective, which can be
specified by passing a list of length 1, i.e. <code class="docutils literal notranslate"><span class="pre">[72]</span></code> would
be a single hidden layered network with 72 nodes in the hidden layer.</p></li>
<li><p><strong>activation</strong> (<em>str</em>) – The activation function to use for each hidden layer. The output layer
of the network is linear (has no activation function).</p></li>
<li><p><strong>z2_equivar</strong> (<em>bool</em>) – Whether or not to impose z2 equivariance. This changes the transformation
such that the neural networks have no bias term and s(-v) = s(v) which
imposes a <span class="math notranslate nohighlight">\(\mathbb{Z}_2\)</span> symmetry.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>A sequence of affine transformations, which we refer to as a real NVP
(Non-volume preserving) flow.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="#anvil.layers.Sequential" title="anvil.layers.Sequential">anvil.layers.Sequential</a></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#module-anvil.neural_network" title="anvil.neural_network"><code class="xref py py-mod docutils literal notranslate"><span class="pre">anvil.neural_network</span></code></a></p>
</div>
</dd></dl>

</section>
<section id="module-anvil.neural_network">
<span id="anvil-neural-network-module"></span><h2>anvil.neural_network module<a class="headerlink" href="#module-anvil.neural_network" title="Permalink to this headline">¶</a></h2>
<p>neural_network.py</p>
<p>Module containing neural networks which are used as part of transformation
layers, found in <a class="reference internal" href="#module-anvil.layers" title="anvil.layers"><code class="xref py py-mod docutils literal notranslate"><span class="pre">anvil.layers</span></code></a>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="anvil.neural_network.DenseNeuralNetwork">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">anvil.neural_network.</span></span><span class="sig-name descname"><span class="pre">DenseNeuralNetwork</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size_in</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">size_out</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hidden_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">activation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bias</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.neural_network.DenseNeuralNetwork" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">torch.nn.modules.module.Module</span></code></p>
<p>Dense neural networks used in coupling layers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size_in</strong> (<em>int</em>) – Number of nodes in the input layer</p></li>
<li><p><strong>size_out</strong> (<em>int</em>) – Number of nodes in the output layer</p></li>
<li><p><strong>hidden_shape</strong> (<em>(</em><em>&lt;class 'tuple'&gt;</em><em>, </em><em>&lt;class 'list'&gt;</em><em>)</em>) – Tuple specifying the number of nodes in the intermediate layers</p></li>
<li><p><strong>activation</strong> (<em>str</em>) – Key representing the activation function used for each layer
except the final one. Valid options can be found in
<code class="docutils literal notranslate"><span class="pre">ACTIVATION_LAYERS</span></code>.</p></li>
<li><p><strong>bias</strong> (<em>bool</em>) – Whether to use biases in networks.</p></li>
</ul>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="anvil.neural_network.DenseNeuralNetwork.network">
<span class="sig-name descname"><span class="pre">network</span></span><a class="headerlink" href="#anvil.neural_network.DenseNeuralNetwork.network" title="Permalink to this definition">¶</a></dt>
<dd><p>A PyTorch Module object containing the layers of the neural network.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>torch.nn.Sequential</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.neural_network.DenseNeuralNetwork.forward">
<span class="sig-name descname"><span class="pre">forward</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v_in</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.neural_network.DenseNeuralNetwork.forward" title="Permalink to this definition">¶</a></dt>
<dd><p>Forward pass of the network.</p>
<p>Takes a tensor of shape <code class="docutils literal notranslate"><span class="pre">(batch_size,</span> <span class="pre">size_in)</span></code> and returns a new tensor of
shape <code class="docutils literal notranslate"><span class="pre">(batch_size,</span> <span class="pre">size_out)</span></code> .</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>v_in</strong> (<em>torch.Tensor</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>torch.Tensor</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="anvil.neural_network.DenseNeuralNetwork.training">
<span class="sig-name descname"><span class="pre">training</span></span><em class="property"><span class="pre">:</span> <span class="pre">bool</span></em><a class="headerlink" href="#anvil.neural_network.DenseNeuralNetwork.training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-anvil.observables">
<span id="anvil-observables-module"></span><h2>anvil.observables module<a class="headerlink" href="#module-anvil.observables" title="Permalink to this headline">¶</a></h2>
<p>observables.py</p>
<dl class="py function">
<dt class="sig sig-object py" id="anvil.observables.abs_magnetization_sq">
<span class="sig-prename descclassname"><span class="pre">anvil.observables.</span></span><span class="sig-name descname"><span class="pre">abs_magnetization_sq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">magnetization</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.observables.abs_magnetization_sq" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sample mean of the absolute magnetization, squared, for each member
of a bootstap ensemble.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>magnetization</strong> (<em>numpy.ndarray</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.observables.abs_magnetization_sq_from_fit">
<span class="sig-prename descclassname"><span class="pre">anvil.observables.</span></span><span class="sig-name descname"><span class="pre">abs_magnetization_sq_from_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fit_zero_momentum_correlator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.observables.abs_magnetization_sq_from_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns numpy array containing a value for the absolute magnetization squared
for each member of the bootstrap ensemble for whom <a class="reference internal" href="#anvil.observables.fit_zero_momentum_correlator" title="anvil.observables.fit_zero_momentum_correlator"><code class="xref py py-func docutils literal notranslate"><span class="pre">fit_zero_momentum_correlator()</span></code></a>
successfully converged.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.observables.autocorrelation">
<span class="sig-prename descclassname"><span class="pre">anvil.observables.</span></span><span class="sig-name descname"><span class="pre">autocorrelation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chain</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.observables.autocorrelation" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the autocorrelation function for a one-dimensional array.</p>
<p>The aucorrelation function is normalised such that <span class="math notranslate nohighlight">\(\Gamma(0) = 1\)</span> .</p>
<p class="rubric">Notes</p>
<p>See <code class="xref py py-func docutils literal notranslate"><span class="pre">scipy.signal.correlate()</span></code> with <code class="docutils literal notranslate"><span class="pre">mode=&quot;same&quot;</span></code> for more details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>chain</strong> (<em>numpy.ndarray</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.observables.correlation_length_from_fit">
<span class="sig-prename descclassname"><span class="pre">anvil.observables.</span></span><span class="sig-name descname"><span class="pre">correlation_length_from_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fit_zero_momentum_correlator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.observables.correlation_length_from_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns numpy array containing a value for the  correlation length for each member
of the bootstrap ensemble for whom <a class="reference internal" href="#anvil.observables.fit_zero_momentum_correlator" title="anvil.observables.fit_zero_momentum_correlator"><code class="xref py py-func docutils literal notranslate"><span class="pre">fit_zero_momentum_correlator()</span></code></a> successfully
converged.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.observables.cosh_shift">
<span class="sig-prename descclassname"><span class="pre">anvil.observables.</span></span><span class="sig-name descname"><span class="pre">cosh_shift</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">A</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.observables.cosh_shift" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies a three-parameter cosh function to a provided array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x</strong> (<em>numpy.ndarray</em>) – </p></li>
<li><p><strong>xi</strong> (<em>float</em>) – </p></li>
<li><p><strong>A</strong> (<em>float</em>) – </p></li>
<li><p><strong>c</strong> (<em>float</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.observables.effective_pole_mass">
<span class="sig-prename descclassname"><span class="pre">anvil.observables.</span></span><span class="sig-name descname"><span class="pre">effective_pole_mass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zero_momentum_correlator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.observables.effective_pole_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Effective pole mass defined by</p>
<div class="math notranslate nohighlight">
\[m_p^\mathrm{eff} = \cosh^{-1} \left(
\frac{\tilde{G}(t-1) + \tilde{G}(t+1)}{2 \tilde{G}(t)} \right)\]</div>
<p>where <span class="math notranslate nohighlight">\(\tilde{G}(t)\)</span> is the correlator in time-momentum representation
with momentum <span class="math notranslate nohighlight">\(p = 0\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>zero_momentum_correlator</strong> (<em>numpy.ndarray</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.observables.fit_zero_momentum_correlator">
<span class="sig-prename descclassname"><span class="pre">anvil.observables.</span></span><span class="sig-name descname"><span class="pre">fit_zero_momentum_correlator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zero_momentum_correlator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">training_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cosh_fit_window</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.observables.fit_zero_momentum_correlator" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses scipy.optimize.curve_fit to fit a cosh function (i.e. exponential decay
with periodicity) to each correlator in the bootrap ensemble.</p>
<p>The correlator decays as a pure exponential in the limit of large separations,
and the characteristic scale of this decay is the correlation length, whose
reciprocal is a.k.a the (effective) pole mass.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>zero_momentum_correlator</strong> – The two point correlation function at zero spatial momentum, i.e. the
correlation between 1-d ‘slices’.</p></li>
<li><p><strong>training_geometry</strong> – The anvil.geometry object defining the lattice.</p></li>
<li><p><strong>cosh_fit_window</strong> (<em>slice object</em>) – A slice object which selects the points (i.e. separations) to include in the
fit. In general the signal at short separations will be contaminated by
shorter modes and should not be included in the fit.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>xi</strong> (<em>list</em>) – List of optimal correlation lengths for each member of the bootstrap ensemble
for whom the fitting process converged successfully.</p></li>
<li><p><strong>A</strong> (<em>list</em>) – Same as above, but for the amplitude of the cosh function.</p></li>
<li><p><strong>c</strong> (<em>list</em>) – Same as above, but for the global shift in the fit (which should correspond
to the absolute value of the magnetization, squared.</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#anvil.observables.cosh_shift" title="anvil.observables.cosh_shift"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.observables.cosh_shift()</span></code></a></dt><dd><p>the function being fit to the data.</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.observables.ising_energy">
<span class="sig-prename descclassname"><span class="pre">anvil.observables.</span></span><span class="sig-name descname"><span class="pre">ising_energy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">two_point_correlator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.observables.ising_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>Ising energy density, defined as the two point correlator at the minimum
lattice spacing.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.observables.low_momentum_correlation_length">
<span class="sig-prename descclassname"><span class="pre">anvil.observables.</span></span><span class="sig-name descname"><span class="pre">low_momentum_correlation_length</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">two_point_correlator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">susceptibility</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.observables.low_momentum_correlation_length" title="Permalink to this definition">¶</a></dt>
<dd><p>An estimate for the correlation length based on the low-momentum behaviour
of the correlation function.</p>
<div class="math notranslate nohighlight">
\[\xi^2 = \frac{1}{2} \sum_{\mu=1}^2 \frac{1}{4 \sin( \pi / L)} \left(
\frac{\tilde{G}(0)}{\mathrm{Re}\tilde{G}(\hat{q}_\mu)}
- 1 \right)\]</div>
<p>Here, <span class="math notranslate nohighlight">\(\tilde{G}(q)\)</span> is the Fourier transform of the correlation function, and
<span class="math notranslate nohighlight">\(\hat{q}_\mu\)</span> are the two smallest non-zero momentum vectors on the lattice.</p>
<dl class="simple">
<dt>Specifically, we have</dt><dd><ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\tilde{G}(0) = \chi\)</span> , the susceptibility</p></li>
<li><p><span class="math notranslate nohighlight">\(\hat{q}_1 = (2\pi/L, 0)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\hat{q}_2 = (0, 2\pi/L)\)</span></p></li>
</ul>
</dd>
</dl>
<p>Reference: <a class="reference external" href="https://doi.org/10.1103/PhysRevD.58.105007">https://doi.org/10.1103/PhysRevD.58.105007</a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>two_point_correlator</strong> (<em>numpy.ndarray</em>) – </p></li>
<li><p><strong>susceptibility</strong> (<em>numpy.ndarray</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.observables.magnetic_susceptibility">
<span class="sig-prename descclassname"><span class="pre">anvil.observables.</span></span><span class="sig-name descname"><span class="pre">magnetic_susceptibility</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">magnetization</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">abs_magnetization_sq</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.observables.magnetic_susceptibility" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the magnetic susceptibility for each member of a bootstrap ensemble.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>magnetization</strong> (<em>numpy.ndarray</em>) – </p></li>
<li><p><strong>abs_magnetization_sq</strong> (<em>numpy.ndarray</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.observables.magnetization">
<span class="sig-prename descclassname"><span class="pre">anvil.observables.</span></span><span class="sig-name descname"><span class="pre">magnetization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">configs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bootstrap_sample_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bootstrap_seed</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.observables.magnetization" title="Permalink to this definition">¶</a></dt>
<dd><p>Configuration-wise magnetization for a bootstrapped sample of configurations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>configs</strong> (<em>torch.Tensor</em>) – the sample of field configurations</p></li>
<li><p><strong>bootstrap_sample_size</strong> (<em>int</em>) – number of bootstrap resamples of the original sample</p></li>
<li><p><strong>bootstrap_seed</strong> (<em>int</em>) – integer denoting a seed for the rng used in the bootstrapping, for
reproducibility purposes.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>array of dimensions <code class="docutils literal notranslate"><span class="pre">(boostrap_sample_size,</span> <span class="pre">sample_size)</span></code> containing
magnetizations.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#anvil.utils.bootstrap_sample" title="anvil.utils.bootstrap_sample"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.utils.bootstrap_sample()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.observables.magnetization_autocorr">
<span class="sig-prename descclassname"><span class="pre">anvil.observables.</span></span><span class="sig-name descname"><span class="pre">magnetization_autocorr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">magnetization_series</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.observables.magnetization_autocorr" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the autocorrelation function for the configuration-wise magnetization
of a sample of configurations, assuming that the order in which they appear in
the array corresponds to the order in which they were generated by a dynamical
process (i.e. Markov-chain Monte Carlo).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>magnetization_series</strong> (<em>numpy.ndarray</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.observables.magnetization_integrated_autocorr">
<span class="sig-prename descclassname"><span class="pre">anvil.observables.</span></span><span class="sig-name descname"><span class="pre">magnetization_integrated_autocorr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">magnetization_autocorr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.observables.magnetization_integrated_autocorr" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the cumulative sum of the autocorrelation funcion for the configuration-
wise magnetization, i.e. an estimate of the integrated autocorrelation computed
in a window of increasing size.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>magnetization_autocorr</strong> (<em>numpy.ndarray</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.observables.magnetization_optimal_window">
<span class="sig-prename descclassname"><span class="pre">anvil.observables.</span></span><span class="sig-name descname"><span class="pre">magnetization_optimal_window</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">magnetization_integrated_autocorr</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.observables.magnetization_optimal_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the optimal window size which minimises the total error in an estimate
of integrated autocorrelation for the configuration-wise magnetization. See
<a class="reference internal" href="#anvil.observables.optimal_window" title="anvil.observables.optimal_window"><code class="xref py py-func docutils literal notranslate"><span class="pre">optimal_window()</span></code></a> for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>magnetization_integrated_autocorr</strong> (<em>numpy.ndarray</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.observables.magnetization_series">
<span class="sig-prename descclassname"><span class="pre">anvil.observables.</span></span><span class="sig-name descname"><span class="pre">magnetization_series</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">configs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.observables.magnetization_series" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the configuration-wise magnetization for a sample of configurations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>configs</strong> (<em>torch.Tensor</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.observables.optimal_window">
<span class="sig-prename descclassname"><span class="pre">anvil.observables.</span></span><span class="sig-name descname"><span class="pre">optimal_window</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">integrated</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mult</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.observables.optimal_window" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates a window length such that, when the integrated autocorrelation is
calculated within this window, the sum of statistical and systematic errors is
minimised according to a self-consistent formula.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>integrated</strong> (<em>numpy.ndarray</em>) – array containing the cumulative sum of the autocorrelation function, i.e.
estimates of the integrated autocorrelation in a ‘window’ of increasing
size.</p></li>
<li><p><strong>mult</strong> (<em>float</em>) – a multiplicative constant, denoted <span class="math notranslate nohighlight">\(S\)</span> in the reference below, which
essentially allows for some tuning of the optimal window based on a visual
inspection of <code class="docutils literal notranslate"><span class="pre">integrated</span></code> using
<code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.plots.plot_magnetization_integrated_autocorr()</span></code> . We expect
the optimal window to correspond to an approximate plateau in <code class="docutils literal notranslate"><span class="pre">integrated</span></code> .</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The size of the window, in which the autocorrelation function is summed,
which is expected to yield an estimate of the integrated autocorrelation
with the minimum error.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>See U. Wolff, Monte Carlo errors with less errors, section 3.3
<a class="reference external" href="http://arXiv.org/abs/hep-lat/0306017v4">http://arXiv.org/abs/hep-lat/0306017v4</a></p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.plots.plot_magnetization_integrated_autocorr()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.observables.second_moment_correlation_length">
<span class="sig-prename descclassname"><span class="pre">anvil.observables.</span></span><span class="sig-name descname"><span class="pre">second_moment_correlation_length</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">two_point_correlator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">susceptibility</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.observables.second_moment_correlation_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Second moment correlation length, defined as the normalised second
moment of the two point correlator.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.observables.susceptibility">
<span class="sig-prename descclassname"><span class="pre">anvil.observables.</span></span><span class="sig-name descname"><span class="pre">susceptibility</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">two_point_correlator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.observables.susceptibility" title="Permalink to this definition">¶</a></dt>
<dd><p>Susceptibility as defined by the two point correlation function in
Fourier space for momentum <span class="math notranslate nohighlight">\((p_1, p_2) = (0, 0)\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>two_point_correlator</strong> (<em>numpy.ndarray</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.observables.two_point_connected_correlator">
<span class="sig-prename descclassname"><span class="pre">anvil.observables.</span></span><span class="sig-name descname"><span class="pre">two_point_connected_correlator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">two_point_correlator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">abs_magnetization_sq</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.observables.two_point_connected_correlator" title="Permalink to this definition">¶</a></dt>
<dd><p>Connected two point correlation function, obtained by subtracting the expected
value of the absolute magnetization, squared.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>two_point_correlator</strong> (<em>numpy.ndarray</em>) – </p></li>
<li><p><strong>abs_magnetization_sq</strong> (<em>numpy.ndarray</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.observables.two_point_correlator">
<span class="sig-prename descclassname"><span class="pre">anvil.observables.</span></span><span class="sig-name descname"><span class="pre">two_point_correlator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">configs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">training_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bootstrap_sample_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bootstrap_seed</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_multiprocessing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.observables.two_point_correlator" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the two point correlation function for a bootstrapped sample of
configurations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>configs</strong> (<em>torch.Tensor</em>) – the sample of field configurations</p></li>
<li><p><strong>training_geometry</strong> – the geometry object defining the lattice</p></li>
<li><p><strong>bootstrap_sample_size</strong> (<em>int</em>) – number of bootstrap resamples of the original sample</p></li>
<li><p><strong>bootstrap_seed</strong> (<em>int</em>) – integer denoting a seed for the rng used in the bootstrapping, for
reproducibility purposes.</p></li>
<li><p><strong>use_multiprocessing</strong> (<em>bool</em>) – if False, do not use <code class="docutils literal notranslate"><span class="pre">multiprocessing</span></code> (may be very slow).</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>array containing the correlation function, dimensions
<code class="docutils literal notranslate"><span class="pre">(training_geometry.length,</span> <span class="pre">training_geometry.length,</span> <span class="pre">boostrap_sample_size)</span></code></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>To reduce peak memory requirements, the correlation for each separation is
calculated separately. I.e. we vectorize over the sample (using numpy) but
not over the lattice separations. To speed things up, multiprocessing can
be used to spread the work over multiple processors, meaning that each
<span class="math notranslate nohighlight">\(G(x_i)\)</span> will be allocated to a processor.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#anvil.utils.bootstrap_sample" title="anvil.utils.bootstrap_sample"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.utils.bootstrap_sample()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.observables.zero_momentum_correlator">
<span class="sig-prename descclassname"><span class="pre">anvil.observables.</span></span><span class="sig-name descname"><span class="pre">zero_momentum_correlator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">two_point_correlator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.observables.zero_momentum_correlator" title="Permalink to this definition">¶</a></dt>
<dd><p>Two point correlation function in time-momentum representation, where the
momentum is zero. Equivalent to summing over one of the dimensions of the
correlation function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>two_point_correlator</strong> (<em>numpy.ndarray</em>) – </p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>numpy.ndarray</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-anvil.plot">
<span id="anvil-plot-module"></span><h2>anvil.plot module<a class="headerlink" href="#module-anvil.plot" title="Permalink to this headline">¶</a></h2>
<p>plot.py</p>
<p>module containing all actions for plotting observables</p>
<dl class="py function">
<dt class="sig sig-object py" id="anvil.plot.plot_bootstrap_effective_pole_mass">
<span class="sig-prename descclassname"><span class="pre">anvil.plot.</span></span><span class="sig-name descname"><span class="pre">plot_bootstrap_effective_pole_mass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">effective_pole_mass</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.plot.plot_bootstrap_effective_pole_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>For each value of t from 1 to L-2, plot a bootstrap distribution of
effective_pole_mass[t]</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.plot.plot_bootstrap_ising_energy">
<span class="sig-prename descclassname"><span class="pre">anvil.plot.</span></span><span class="sig-name descname"><span class="pre">plot_bootstrap_ising_energy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ising_energy</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.plot.plot_bootstrap_ising_energy" title="Permalink to this definition">¶</a></dt>
<dd><p>plot a bootstrap distribution of the ising_energy</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.plot.plot_bootstrap_multiple_numbers">
<span class="sig-prename descclassname"><span class="pre">anvil.plot.</span></span><span class="sig-name descname"><span class="pre">plot_bootstrap_multiple_numbers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">observable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.plot.plot_bootstrap_multiple_numbers" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a 2D tensor with boostrap sample on the final axis, yield a figure
with a histogram for each element’s bootstrap sample</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.plot.plot_bootstrap_single_number">
<span class="sig-prename descclassname"><span class="pre">anvil.plot.</span></span><span class="sig-name descname"><span class="pre">plot_bootstrap_single_number</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">observable</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">label</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.plot.plot_bootstrap_single_number" title="Permalink to this definition">¶</a></dt>
<dd><p>Given a 1 dimensional tensor of observables, plot a histogram of the
distribution</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.plot.plot_bootstrap_susceptibility">
<span class="sig-prename descclassname"><span class="pre">anvil.plot.</span></span><span class="sig-name descname"><span class="pre">plot_bootstrap_susceptibility</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">susceptibility</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.plot.plot_bootstrap_susceptibility" title="Permalink to this definition">¶</a></dt>
<dd><p>plot a bootstrap distribution of the susceptibility</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.plot.plot_bootstrap_zero_momentum_2pf">
<span class="sig-prename descclassname"><span class="pre">anvil.plot.</span></span><span class="sig-name descname"><span class="pre">plot_bootstrap_zero_momentum_2pf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zero_momentum_correlator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.plot.plot_bootstrap_zero_momentum_2pf" title="Permalink to this definition">¶</a></dt>
<dd><p>For each value of t, plot a boostrap distribution of
zero_momentum_correlator[t]</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.plot.plot_correlation_length">
<span class="sig-prename descclassname"><span class="pre">anvil.plot.</span></span><span class="sig-name descname"><span class="pre">plot_correlation_length</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">effective_pole_mass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low_momentum_correlation_length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">correlation_length_from_fit</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.plot.plot_correlation_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots three estimates of correlation length.</p>
<dl class="simple">
<dt>These are:</dt><dd><ol class="arabic simple">
<li><dl class="simple">
<dt>Estimate from fitting a cosh function to the correlation between</dt><dd><p>1-dimensional slices, using py:func:<cite>correlation_length_from_fit</cite></p>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Reciprocal of the effective pole mass estimator, using</dt><dd><p><code class="xref py py-func docutils literal notranslate"><span class="pre">effective_pole_mass()</span></code> (evaluated at each separation, <span class="math notranslate nohighlight">\(x_2\)</span>.</p>
</dd>
</dl>
</li>
<li><p>Low momentum estimate, using <code class="xref py py-func docutils literal notranslate"><span class="pre">low_momentum_correlation_length()</span></code></p></li>
</ol>
</dd>
</dl>
<p>Points and errorbars are means and standard deviations across a boostrap ensemble,
which is assumed to be the last (<code class="docutils literal notranslate"><span class="pre">-1</span></code>) dimension of input arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>effective_pole_mass</strong> – Array containing estimate of the effective pole mass, for each separation
and each member of the bootstrap ensemble</p></li>
<li><p><strong>low_momentum_correlation_length</strong> – Array containing a low-momentum estimate of the correlation length for
each member of the bootstrap ensemble.</p></li>
<li><p><strong>correlation_length_from_fit</strong> – Array containing an estimate of the correlation length from a cosh fit
to the correlation function, for each member of the bootstrap
ensemble.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>matplotlib.figure.Figure</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#anvil.observables.fit_zero_momentum_correlator" title="anvil.observables.fit_zero_momentum_correlator"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.observables.fit_zero_momentum_correlator()</span></code></a>, <a class="reference internal" href="#anvil.table.table_correlation_length" title="anvil.table.table_correlation_length"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.table.table_correlation_length()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.plot.plot_effective_pole_mass">
<span class="sig-prename descclassname"><span class="pre">anvil.plot.</span></span><span class="sig-name descname"><span class="pre">plot_effective_pole_mass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">training_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">effective_pole_mass</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.plot.plot_effective_pole_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the (effective) pole mass as a function of ‘time’ separation.</p>
<p>Points and errorbars are means and standard deviations across a boostrap ensemble,
which is assumed to be the last (<code class="docutils literal notranslate"><span class="pre">-1</span></code>) dimension of input arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>training_geometry</strong> – Geometry object defining the lattice.</p></li>
<li><p><strong>effective_pole_mass</strong> – Array containing bootstrap ensemble of effective pole mass, for each
separation <span class="math notranslate nohighlight">\(t = 1, \ldots, T - 1\)</span></p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>matplotlib.figure.Figure</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#anvil.table.table_effective_pole_mass" title="anvil.table.table_effective_pole_mass"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.table.table_effective_pole_mass()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.plot.plot_magnetization">
<span class="sig-prename descclassname"><span class="pre">anvil.plot.</span></span><span class="sig-name descname"><span class="pre">plot_magnetization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">magnetization_series</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.plot.plot_magnetization" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots a histogram of the magnetization of each configuration in the Markov
chain resulting from the Metropolis-Hastings sampling phase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>magnetization_series</strong> – Array containing the magnetization for each configuration in the output
sample from the Metropolis-Hastings sampling phase.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>matplotlib.figure.Figure</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#anvil.plot.plot_magnetization_series" title="anvil.plot.plot_magnetization_series"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.plot.plot_magnetization_series()</span></code></a>, <a class="reference internal" href="#anvil.table.table_magnetization" title="anvil.table.table_magnetization"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.table.table_magnetization()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.plot.plot_magnetization_autocorr">
<span class="sig-prename descclassname"><span class="pre">anvil.plot.</span></span><span class="sig-name descname"><span class="pre">plot_magnetization_autocorr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">magnetization_autocorr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">magnetization_optimal_window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_interval</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.plot.plot_magnetization_autocorr" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the autocorrelation function for the magnetization of the sequence of
configurations generated in the Metropolis-Hastings sampling phase.</p>
<p>The x-axis corresponds to a number of steps separating pairs of configurations
in the sequence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>magnetization_autocorr</strong> – Array containing the autocorrelation function of the magnetization for each
configuration in the output sample from the Metropolis-Hastings sampling phase.</p></li>
<li><p><strong>magnetization_optimal_window</strong> (<em>int</em>) – The size of the window in which the integrated autocorrelation time is to be
computed such that the total error is minimized.</p></li>
<li><p><strong>sample_interval</strong> (<em>int</em>) – The number of Metropolis updates which were discarded between each
configuration appearing in the input series.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>matplotlib.figure.Figure</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#anvil.observables.optimal_window" title="anvil.observables.optimal_window"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.observables.optimal_window()</span></code></a>, <a class="reference internal" href="#anvil.plot.plot_magnetization_integrated_autocorr" title="anvil.plot.plot_magnetization_integrated_autocorr"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.plot.plot_magnetization_integrated_autocorr()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.plot.plot_magnetization_integrated_autocorr">
<span class="sig-prename descclassname"><span class="pre">anvil.plot.</span></span><span class="sig-name descname"><span class="pre">plot_magnetization_integrated_autocorr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">magnetization_integrated_autocorr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">magnetization_optimal_window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_interval</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.plot.plot_magnetization_integrated_autocorr" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the integrated autocorrelation function for the magnetization of the
sequence of configurations generated in the Metropolis-Hastings sampling phase.</p>
<p>The x axis represents the size of the ‘window’ in which the summation is performed,
i.e. the point at which the autocorrelation function is truncated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>magnetization_integrated_autocorr</strong> – Array containing the cumulative sum of the autocorrelation function of the
magnetization for each configuration in the output sample from the Metropolis-
Hastings sampling phase.</p></li>
<li><p><strong>magnetization_optimal_window</strong> (<em>int</em>) – The size of the window in which the integrated autocorrelation time is to be
computed such that the total error is minimized.</p></li>
<li><p><strong>sample_interval</strong> (<em>int</em>) – The number of Metropolis updates which were discarded between each
configuration appearing in the input series.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>matplotlib.figure.Figure</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#anvil.observables.optimal_window" title="anvil.observables.optimal_window"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.observables.optimal_window()</span></code></a>, <a class="reference internal" href="#anvil.plot.plot_magnetization_autocorr" title="anvil.plot.plot_magnetization_autocorr"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.plot.plot_magnetization_autocorr()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.plot.plot_magnetization_series">
<span class="sig-prename descclassname"><span class="pre">anvil.plot.</span></span><span class="sig-name descname"><span class="pre">plot_magnetization_series</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">magnetization_series</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_interval</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.plot.plot_magnetization_series" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the magnetization of each configuration in the Markov chain over the
course of the Metropolis-Hastings sampling phase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>magnetization_series</strong> – Array containing the magnetization for each configuration in the output
sample from the Metropolis-Hastings sampling phase.</p></li>
<li><p><strong>sample_interval</strong> – The number of Metropolis updates which were discarded between each
configuration appearing in the input series.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>matplotlib.figure.Figure</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#anvil.plot.plot_magnetization" title="anvil.plot.plot_magnetization"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.plot.plot_magnetization()</span></code></a>, <a class="reference internal" href="#anvil.table.table_magnetization" title="anvil.table.table_magnetization"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.table.table_magnetization()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.plot.plot_two_point_correlator">
<span class="sig-prename descclassname"><span class="pre">anvil.plot.</span></span><span class="sig-name descname"><span class="pre">plot_two_point_correlator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">two_point_correlator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.plot.plot_two_point_correlator" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents the two point correlator as a heatmap.</p>
<p>The data shown is the mean of a bootstrap sample of correlation functions, and is
normalised so that <span class="math notranslate nohighlight">\(G(0, 0) = 1\)</span>. The colour axis is scaled using a symmetric
log scale, with a linear region spanning <span class="math notranslate nohighlight">\([-0.01, 0.01]\)</span>.</p>
<p>The bootstrap dimension is assumed to be the last (<code class="docutils literal notranslate"><span class="pre">-1</span></code>) dimension of input arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>two_point_correlator</strong> – Array containing two point correlation function for each two-dimensional
separation <span class="math notranslate nohighlight">\((x_1, x_2)\)</span>, for each member of a bootstrap ensemble.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>matplotlib.figure.Figure</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#anvil.plot.plot_two_point_correlator_error" title="anvil.plot.plot_two_point_correlator_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.plot.plot_two_point_correlator_error()</span></code></a>, <a class="reference internal" href="#anvil.table.table_two_point_correlator" title="anvil.table.table_two_point_correlator"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.table.table_two_point_correlator()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.plot.plot_two_point_correlator_error">
<span class="sig-prename descclassname"><span class="pre">anvil.plot.</span></span><span class="sig-name descname"><span class="pre">plot_two_point_correlator_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">two_point_correlator</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.plot.plot_two_point_correlator_error" title="Permalink to this definition">¶</a></dt>
<dd><p>Heatmap of the error in the two point correlator for each separation.</p>
<p>The error is computed as the standard deviation over the bootstrap sample. The
data shown is this error divided by the mean of the bootstrap sample, i.e. the
fractional error.</p>
<p>The bootstrap dimension is assumed to be the last (<code class="docutils literal notranslate"><span class="pre">-1</span></code>) dimension of input arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>two_point_correlator</strong> – Array containing two point correlation function for each two-dimensional
separation <span class="math notranslate nohighlight">\((x_1, x_2)\)</span>, for each member of a bootstrap ensemble.</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>matplotlib.figure.Figure</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#anvil.plot.plot_two_point_correlator" title="anvil.plot.plot_two_point_correlator"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.plot.plot_two_point_correlator()</span></code></a>, <a class="reference internal" href="#anvil.table.table_two_point_correlator" title="anvil.table.table_two_point_correlator"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.table.table_two_point_correlator()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.plot.plot_zero_momentum_correlator">
<span class="sig-prename descclassname"><span class="pre">anvil.plot.</span></span><span class="sig-name descname"><span class="pre">plot_zero_momentum_correlator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zero_momentum_correlator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">training_geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fit_zero_momentum_correlator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cosh_fit_window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">plot_cosh_fit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.plot.plot_zero_momentum_correlator" title="Permalink to this definition">¶</a></dt>
<dd><p>Plots the correlation function for pairs of one-dimensional ‘slices’, otherwise
referred to as the two point correlator at zero spatial momentum, as a function of
time.</p>
<p>Points and errorbars are means and standard deviations across a boostrap ensemble,
which is assumed to be the last (<code class="docutils literal notranslate"><span class="pre">-1</span></code>) dimension of input arrays.</p>
<p>Optionally plots a <span class="math notranslate nohighlight">\(1\sigma\)</span> confidence interval for a pure-exponential (cosh)
fit performed for each member of the bootstrap sample in
<code class="xref py py-func docutils literal notranslate"><span class="pre">fit_zero_momentum_correlator()</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>zero_momentum_correlator</strong> – Array containing bootstrapped correlation function</p></li>
<li><p><strong>training_geometry</strong> – Geometry object defining the lattice</p></li>
<li><p><strong>fit_zero_momentum_correlator</strong> – The parameters resulting from a least-squares fit of a cosh function to the
correlator</p></li>
<li><p><strong>cosh_fit_window</strong> (<em>slice</em>) – Slice object which indexes the lattice separations that were used to perform
the cosh fit to the correlation function</p></li>
<li><p><strong>plot_cosh_fit</strong> (<em>bool</em>) – If False, only plot the correlation function, and not the result of the fit</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>matplotlib.figure.Figure</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#anvil.table.table_zero_momentum_correlator" title="anvil.table.table_zero_momentum_correlator"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.table.table_zero_momentum_correlator()</span></code></a></p>
</div>
</dd></dl>

</section>
<section id="module-anvil.sample">
<span id="anvil-sample-module"></span><h2>anvil.sample module<a class="headerlink" href="#module-anvil.sample" title="Permalink to this headline">¶</a></h2>
<p>sample.py</p>
<p>Module containing functions related to sampling from a trained model</p>
<dl class="py exception">
<dt class="sig sig-object py" id="anvil.sample.LogRatioNanError">
<em class="property"><span class="pre">exception</span> </em><span class="sig-prename descclassname"><span class="pre">anvil.sample.</span></span><span class="sig-name descname"><span class="pre">LogRatioNanError</span></span><a class="headerlink" href="#anvil.sample.LogRatioNanError" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">Exception</span></code></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.sample.acceptance">
<span class="sig-prename descclassname"><span class="pre">anvil.sample.</span></span><span class="sig-name descname"><span class="pre">acceptance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">metropolis_hastings</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.sample.acceptance" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the fraction of proposals that were accepted during the Metropolis-
Hastings simulation.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.sample.calc_tau_chain">
<span class="sig-prename descclassname"><span class="pre">anvil.sample.</span></span><span class="sig-name descname"><span class="pre">calc_tau_chain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">history</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.sample.calc_tau_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns an estimate of the integrated autocorrelation time based on the
accept/reject ‘history’ of a Metropolis simulation.</p>
<p>The estimate is based on the insight that the autocorrelation function is
given by</p>
<div class="math notranslate nohighlight">
\[\frac{\Gamma(t)}{\Gamma(0)} =
\Pr( t \text{ consecutive rejections} )\]</div>
<p>which can be easily estimated from a finite sampling phase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>history</strong> (<em>list</em>) – List containing the history of the Mertropolis simulation in the form of
ones (proposal accepted) and zeros (proposal rejected)</p>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Estimate of the integrated autocorrelation time.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Reference: <a class="reference external" href="https://arxiv.org/abs/1904.12072">https://arxiv.org/abs/1904.12072</a></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.sample.configs">
<span class="sig-prename descclassname"><span class="pre">anvil.sample.</span></span><span class="sig-name descname"><span class="pre">configs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">metropolis_hastings</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.sample.configs" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns sample of configurations from the Metropolis-Hastings simulation.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.sample.gen_candidates">
<span class="sig-prename descclassname"><span class="pre">anvil.sample.</span></span><span class="sig-name descname"><span class="pre">gen_candidates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.sample.gen_candidates" title="Permalink to this definition">¶</a></dt>
<dd><p>Generates a batch of candidate field configurations from a trained model.</p>
<p>Returns the batch along with the ‘log ratio’</p>
<div class="math notranslate nohighlight">
\[\log (\tilde{p}_\theta(\phi)) - \log(p(\phi))\]</div>
<p>where the global shift due to the normalisations of the probability
densities is not calculated (in any case the normalisation of the target
is typically not known).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model</strong> – Traing flow model which is able to map latent variables from the base
distribution to candidate field configurations distributed according to
<span class="math notranslate nohighlight">\(\tilde{p}_\theta(\phi)\)</span></p></li>
<li><p><strong>base</strong> – Base distribution from which latent variables are generated.</p></li>
<li><p><strong>target</strong> – Target distribution - probably a field theory - from which we would
like to sample.</p></li>
<li><p><strong>num</strong> (<em>int</em>) – Number of candidate configurations to generate in this batch.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>torch.Tensor</em> – Tensor containing the candidate configurations, dimensions
<code class="docutils literal notranslate"><span class="pre">(num,</span> <span class="pre">lattice_size)</span></code></p></li>
<li><p><em>torch.Tensor</em> – Tensor containing the ‘log ratio’ as defined above.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>tuple</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.sample.metropolis_hastings">
<span class="sig-prename descclassname"><span class="pre">anvil.sample.</span></span><span class="sig-name descname"><span class="pre">metropolis_hastings</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loaded_model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">training_base_dist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">training_target_dist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thermalization</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sample_interval</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.sample.metropolis_hastings" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs a Metropolis-Hastings sampling simulation given a trained model and a
target probability distribution.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loaded_model</strong> – Trained model which generates candidate configurations by passing latent
variables through its layers.</p></li>
<li><p><strong>training_base_dist</strong> – Distribution objet that generates latent variables and an associated
(log) probability density.</p></li>
<li><p><strong>training_target_dist</strong> – The distribution from which we would like to sample using the Metropolis-
Hastings algorithm.</p></li>
<li><p><strong>sample_size</strong> (<em>int</em>) – The number of configurations we desire in the resulting sample.</p></li>
<li><p><strong>thermalization</strong> (<em>(</em><em>&lt;class 'int'&gt;</em><em>, </em><em>&lt;class 'NoneType'&gt;</em><em>)</em>) – The number of updates to discard before we begin accumulating configurations
in the output sample.</p></li>
<li><p><strong>sample_interval</strong> (<em>(</em><em>&lt;class 'int'&gt;</em><em>, </em><em>&lt;class 'NoneType'&gt;</em><em>)</em>) – Optional user-prescribed interval defining the number of updates to discard
between each configuration added to the output sample.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>torch.Tensor</em> – Sample of field configurations distributed according to the target.</p></li>
<li><p><em>float</em> – Estimate of the integrated autocorrelation time of the simulation based
on accept-reject statistics.</p></li>
<li><p><em>float</em> – Fraction of proposals which were accepted during the simulation.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.sample.metropolis_test">
<span class="sig-prename descclassname"><span class="pre">anvil.sample.</span></span><span class="sig-name descname"><span class="pre">metropolis_test</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">current_log_ratio</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">proposal_log_ratio</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.sample.metropolis_test" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the Metropolis acceptance probability for a transition between a
given current and proposed configuration.</p>
<p>The Metropolis test is defined by a conditional probability of transitioning
from the current state <span class="math notranslate nohighlight">\(\phi\)</span> to a proposed state <span class="math notranslate nohighlight">\(\phi'\)</span>, where
the proposal is drawn from the distribution <span class="math notranslate nohighlight">\(\tilde{p}_\theta(\phi')\)</span>
and the target distribution is <span class="math notranslate nohighlight">\(p(\phi)\)</span>:</p>
<div class="math notranslate nohighlight">
\[A(\phi \to \phi') = \min \left( 1,
\frac{\tilde{p}_\theta(\phi)}{p(\phi)}
\frac{p(\phi')}{\tilde{p}_\theta(\phi')} \right)\]</div>
<p>Note that normalisations in this expression cancel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>current_log_ratio</strong> – The logarithm of the ratio of model density to target density for the
current configuration, ignoring normalisations.</p></li>
<li><p><strong>proposal_log_ratio</strong> – The logarithm of the ratio of model density to target density for the
proposed configuration, ignoring normalisations.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The probability <span class="math notranslate nohighlight">\(A(\phi \to \phi')\)</span>.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>It is assumed that the model generates <em>independent</em> candidate configurations,
i.e. <span class="math notranslate nohighlight">\(\tilde{p}_\theta(\phi' \mid \phi) \equiv \tilde{p}_\theta(\phi')\)</span></p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.sample.random">
<span class="sig-prename descclassname"><span class="pre">anvil.sample.</span></span><span class="sig-name descname"><span class="pre">random</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> &#x2192; <span class="pre">x</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">interval</span> <span class="pre">[0,</span> <span class="pre">1).</span><a class="headerlink" href="#anvil.sample.random" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.sample.tau_chain">
<span class="sig-prename descclassname"><span class="pre">anvil.sample.</span></span><span class="sig-name descname"><span class="pre">tau_chain</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">metropolis_hastings</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.sample.tau_chain" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns estimate of the integrated autocorrelation time from the Metropolis-
Hastings simulation.</p>
</dd></dl>

</section>
<section id="module-anvil.table">
<span id="anvil-table-module"></span><h2>anvil.table module<a class="headerlink" href="#module-anvil.table" title="Permalink to this headline">¶</a></h2>
<p>table.py</p>
<p>Module containing all table actions</p>
<dl class="py function">
<dt class="sig sig-object py" id="anvil.table.table_autocorrelation">
<span class="sig-prename descclassname"><span class="pre">anvil.table.</span></span><span class="sig-name descname"><span class="pre">table_autocorrelation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">magnetization_integrated_autocorr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">magnetization_optimal_window</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tau_chain</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">acceptance</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.table.table_autocorrelation" title="Permalink to this definition">¶</a></dt>
<dd><p>Tabulate some information related to the statistical efficiency of the Metropolis-
Hastings sampling phase.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>magnetization_integrated_autocorr</strong> – Array containing the cumulative sum of the autocorrelation function of the
magnetization for each configuration in the sample output by the Metropolis-
Hastings sampling phase.</p></li>
<li><p><strong>magnetization_optimal_window</strong> (<em>int</em>) – Integer corresponding to a window size in which the autocorrelation function
should be summed, such that the resulting estimate of the integrated
autocorrelation has the smallest possible total error.</p></li>
<li><p><strong>tau_chain</strong> (<em>float</em>) – Estimate of the integrated autocorrelation using the accept-reject statistics
of the sampling phase.</p></li>
<li><p><strong>acceptance</strong> (<em>float</em>) – Fraction of proposals which were accepted in the sampling phase.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas.core.frame.DataFrame</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#anvil.observables.optimal_window" title="anvil.observables.optimal_window"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.observables.optimal_window()</span></code></a>, <a class="reference internal" href="#anvil.sample.calc_tau_chain" title="anvil.sample.calc_tau_chain"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.sample.calc_tau_chain()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.table.table_correlation_length">
<span class="sig-prename descclassname"><span class="pre">anvil.table.</span></span><span class="sig-name descname"><span class="pre">table_correlation_length</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">effective_pole_mass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">second_moment_correlation_length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">low_momentum_correlation_length</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">correlation_length_from_fit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">training_geometry</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.table.table_correlation_length" title="Permalink to this definition">¶</a></dt>
<dd><p>Table containing four estimates of correlation length.</p>
<p>Values and errors are means and standard deviations over a bootstrap ensemble,
which is assumed to be the last (<code class="docutils literal notranslate"><span class="pre">-1</span></code>) dimension of input arrays.</p>
<p>Also displays the number of correlation lengths that can fit on the lattice, i.e.
<span class="math notranslate nohighlight">\(\xi / L\)</span> where <span class="math notranslate nohighlight">\(\xi\)</span> is the correlation length and <span class="math notranslate nohighlight">\(L\)</span> is the
linear extent of the lattice.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>effective_pole_mass</strong> – Array containing estimate of the effective pole mass, for each separation
and each member of the bootstrap ensemble</p></li>
<li><p><strong>second_moment_correlation_length</strong> – Estimate of the correlation length based on the second moment of the
two point correlation function, for each member of the bootstrap ensemble.</p></li>
<li><p><strong>low_momentum_correlation_length</strong> – Array containing a low-momentum estimate of the correlation length for each
member of the bootstrap ensemble.</p></li>
<li><p><strong>correlation_length_from_fit</strong> – Array containing an estimate of the correlation length from a cosh fit to
the correlation function, for each member of the bootstrap ensemble.</p></li>
<li><p><strong>training_geometry</strong> – Geometry object defining the lattice.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas.core.frame.DataFrame</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#anvil.observables.fit_zero_momentum_correlator" title="anvil.observables.fit_zero_momentum_correlator"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.observables.fit_zero_momentum_correlator()</span></code></a>, <a class="reference internal" href="#anvil.plot.plot_correlation_length" title="anvil.plot.plot_correlation_length"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.plot.plot_correlation_length()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.table.table_effective_pole_mass">
<span class="sig-prename descclassname"><span class="pre">anvil.table.</span></span><span class="sig-name descname"><span class="pre">table_effective_pole_mass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">effective_pole_mass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">training_geometry</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.table.table_effective_pole_mass" title="Permalink to this definition">¶</a></dt>
<dd><p>Table containing values of the effective pole mass for each separation.</p>
<p>Values and errors are means and standard deviations over a bootstrap ensemble,
which is assumed to be the last (<code class="docutils literal notranslate"><span class="pre">-1</span></code>) dimension of input arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>effective_pole_mass</strong> – Array containing the effective pole mass for each separation, for each
member of the bootstrap ensemble.</p></li>
<li><p><strong>training_geometry</strong> – Geometry object defining the lattice.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas.core.frame.DataFrame</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#anvil.plot.plot_effective_pole_mass" title="anvil.plot.plot_effective_pole_mass"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.plot.plot_effective_pole_mass()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.table.table_fit">
<span class="sig-prename descclassname"><span class="pre">anvil.table.</span></span><span class="sig-name descname"><span class="pre">table_fit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">correlation_length_from_fit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">abs_magnetization_sq_from_fit</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.table.table_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Tabulate the correlation length and magnetization estimates resulting from the
fitting of a cosh to the correlation function.</p>
<p>Values and errors are means and standard deviations over a bootstrap ensemble,
which is assumed to be the last (<code class="docutils literal notranslate"><span class="pre">-1</span></code>) dimension of input arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>correlation_length_from_fit</strong> – </p></li>
<li><p><strong>abs_magnetization_sq_from_fit</strong> – </p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas.core.frame.DataFrame</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#anvil.observables.fit_zero_momentum_correlator" title="anvil.observables.fit_zero_momentum_correlator"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.observables.fit_zero_momentum_correlator()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.table.table_magnetization">
<span class="sig-prename descclassname"><span class="pre">anvil.table.</span></span><span class="sig-name descname"><span class="pre">table_magnetization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">abs_magnetization_sq</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">magnetic_susceptibility</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.table.table_magnetization" title="Permalink to this definition">¶</a></dt>
<dd><p>Table containing quantities derived from the sample-averaged magnetization.</p>
<p>Values and errors are means and standard deviations over a bootstrap ensemble,
which is assumed to be the last (<code class="docutils literal notranslate"><span class="pre">-1</span></code>) dimension of input arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>abs_magnetization_sq</strong> – Array containing the sample mean of the absolute magnetization, squared, for each
member of the bootstrap ensemble.</p></li>
<li><p><strong>magnetic_susceptibility</strong> – Array containing the susceptibility for each member of the bootstrap ensemble.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas.core.frame.DataFrame</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.tables.table_two_point_scalars()</span></code>, <code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.tables.table_fit()</span></code></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.table.table_two_point_correlator">
<span class="sig-prename descclassname"><span class="pre">anvil.table.</span></span><span class="sig-name descname"><span class="pre">table_two_point_correlator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">two_point_correlator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">training_geometry</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.table.table_two_point_correlator" title="Permalink to this definition">¶</a></dt>
<dd><p>Table containing values of the two point correlation function for each
two-dimensional separation.</p>
<p>Values and errors are means and standard deviations over a bootstrap ensemble
which is assumed to be the last (<code class="docutils literal notranslate"><span class="pre">-1</span></code>) dimension of input arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>two_point_correlator</strong> – Array containing the correlation function for each 2-d separation, for each
member of the bootstrap ensemble.</p></li>
<li><p><strong>training_geometry</strong> – Geometry object defining the lattice.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas.core.frame.DataFrame</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#anvil.plot.plot_two_point_correlator" title="anvil.plot.plot_two_point_correlator"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.plot.plot_two_point_correlator()</span></code></a>, <a class="reference internal" href="#anvil.plot.plot_two_point_correlator_error" title="anvil.plot.plot_two_point_correlator_error"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.plot.plot_two_point_correlator_error()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.table.table_two_point_scalars">
<span class="sig-prename descclassname"><span class="pre">anvil.table.</span></span><span class="sig-name descname"><span class="pre">table_two_point_scalars</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ising_energy</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">susceptibility</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.table.table_two_point_scalars" title="Permalink to this definition">¶</a></dt>
<dd><p>Table of scalar observables derived from the two point correlation function.</p>
<p>Values and errors are means and standard deviations over a bootstrap ensemble,
which is assumed to be the last (<code class="docutils literal notranslate"><span class="pre">-1</span></code>) dimension of input arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ising_energy</strong> – Nearest-neighbour iteraction energy.</p></li>
<li><p><strong>susceptibility</strong> – Magnetic susceptibility defined by the sum of the correlation function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas.core.frame.DataFrame</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#anvil.observables.ising_energy" title="anvil.observables.ising_energy"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.observables.ising_energy()</span></code></a>, <a class="reference internal" href="#anvil.observables.susceptibility" title="anvil.observables.susceptibility"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.observables.susceptibility()</span></code></a></p>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.table.table_zero_momentum_correlator">
<span class="sig-prename descclassname"><span class="pre">anvil.table.</span></span><span class="sig-name descname"><span class="pre">table_zero_momentum_correlator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">zero_momentum_correlator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">training_geometry</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.table.table_zero_momentum_correlator" title="Permalink to this definition">¶</a></dt>
<dd><p>Table containing values of the two point correlation function in time-momentum
representation at zero momentum, for each separation.</p>
<p>Values and errors are means and standard deviations over a bootstrap ensemble,
which is assumed to be the last (<code class="docutils literal notranslate"><span class="pre">-1</span></code>) dimension of input arrays.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>zero_momentum_correlator</strong> – Array containing the correlation function for each 1-d separation, for each
member of the bootstrap ensemble.</p></li>
<li><p><strong>training_geometry</strong> – Geometry object defining the lattice.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>pandas.core.frame.DataFrame</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><a class="reference internal" href="#anvil.plot.plot_zero_momentum_correlator" title="anvil.plot.plot_zero_momentum_correlator"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.plot.plot_zero_momentum_correlator()</span></code></a></p>
</div>
</dd></dl>

</section>
<section id="module-anvil.train">
<span id="anvil-train-module"></span><h2>anvil.train module<a class="headerlink" href="#module-anvil.train" title="Permalink to this headline">¶</a></h2>
<p>train.py</p>
<p>Module containing functions required to train model</p>
<dl class="py function">
<dt class="sig sig-object py" id="anvil.train.reverse_kl">
<span class="sig-prename descclassname"><span class="pre">anvil.train.</span></span><span class="sig-name descname"><span class="pre">reverse_kl</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model_log_density</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_log_density</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.train.reverse_kl" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate of the reverse Kullbach-Leibler divergence between the model
and the target density, obtained by averaging over a batch of configurations
generated by the model.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>model_log_density</strong> (<em>torch.Tensor</em>) – column of the logarithm of the probability density for the batch of
configurations generated by the model, as given by the change of
variables formula.</p></li>
<li><p><strong>target_log_density</strong> (<em>torch.Tensor</em>) – column containing the logarithm of the probability density for the
batch of configurations, defined by the action of the field theory.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>torch tensor with single element, corresponding to the estimate of the
reverse KL divergence.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>torch.Tensor</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Only terms which depend on the parameters of the model are necessary for
optimisation. Hence, model_log_density could be simply the logarithm of the
Jacobian determinant of the learnable layers in the normalising flow, and
target_log_density need only be the negative action.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.train.save_checkpoint">
<span class="sig-prename descclassname"><span class="pre">anvil.train.</span></span><span class="sig-name descname"><span class="pre">save_checkpoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">outpath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">epoch</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loss</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">optimizer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scheduler</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.train.save_checkpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>Saves a the state of the model, optimizer and scheduler as a checkpoint file
for later reloading.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>outpath</strong> (<em>str</em>) – </p></li>
<li><p><strong>epoch</strong> (<em>int</em>) – </p></li>
<li><p><strong>loss</strong> (<em>float</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.train.train">
<span class="sig-prename descclassname"><span class="pre">anvil.train.</span></span><span class="sig-name descname"><span class="pre">train</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loaded_model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_dist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_dist</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">train_range</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_batch</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">outpath</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_loss</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loaded_optimizer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loaded_scheduler</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_interval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loss_sample_interval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">25</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.train.train" title="Permalink to this definition">¶</a></dt>
<dd><p>Loop over training updates, periodically saving checkpoints.</p>
<p>Repeatedly calls <a class="reference internal" href="#anvil.train.training_update" title="anvil.train.training_update"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.train.training_update()</span></code></a> and
<a class="reference internal" href="#anvil.train.save_checkpoint" title="anvil.train.save_checkpoint"><code class="xref py py-func docutils literal notranslate"><span class="pre">anvil.train.save_checkpoint()</span></code></a> , until a prescribed number of training
updates have been performed.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loaded_model</strong> – Flow model whose parameters are to be updated.</p></li>
<li><p><strong>base_dist</strong> – Distribution object that generates latent variables to be passed
through the flow model.</p></li>
<li><p><strong>target_dist</strong> – Distribution or field theory which would like to use a trained model
to sample from.</p></li>
<li><p><strong>train_range</strong> (<em>tuple</em>) – Tuple containing indices of the next and last training iteration.</p></li>
<li><p><strong>n_batch</strong> (<em>int</em>) – Number of configurations in a ‘batch’, i.e. which are used to estimate
the gradient of the objective function and hence update the model
parameters.</p></li>
<li><p><strong>outpath</strong> (<em>str</em>) – Path to directory where training outputs are to be saved.</p></li>
<li><p><strong>current_loss</strong> (<em>float</em>) – The current value of the loss or objective function.</p></li>
<li><p><strong>loaded_optimizer</strong> – Optimization algorithm which will be used to update the model parameters.</p></li>
<li><p><strong>loaded_scheduler</strong> – Learning rate scheduler.</p></li>
<li><p><strong>save_interval</strong> (<em>int</em>) – Number of training updates between checkpoints.</p></li>
<li><p><strong>loss_sample_interval</strong> (<em>int</em>) – Rate at which the loss or objective function is sampled for post-analysis.
This also controls the rate at which the progress bar is updated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p></p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>loaded_model</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.train.training_update">
<span class="sig-prename descclassname"><span class="pre">anvil.train.</span></span><span class="sig-name descname"><span class="pre">training_update</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">loaded_model</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">base_dist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_dist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_batch</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">current_loss</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loaded_optimizer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">loaded_scheduler</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.train.training_update" title="Permalink to this definition">¶</a></dt>
<dd><p>A single training update or ‘epoch’.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>loaded_model</strong> – Flow model whose parameters are to be updated.</p></li>
<li><p><strong>base_dist</strong> – Distribution object that generates latent variables to be passed
through the flow model.</p></li>
<li><p><strong>target_dist</strong> – Distribution or field theory which would like to use a trained model
to sample from.</p></li>
<li><p><strong>n_batch</strong> (<em>int</em>) – Number of configurations in a ‘batch’, i.e. which are used to estimate
the gradient of the objective function and hence update the model
parameters.</p></li>
<li><p><strong>current_loss</strong> (<em>float</em>) – The current value of the loss or objective function.</p></li>
<li><p><strong>loaded_optimizer</strong> – Optimization algorithm which will be used to update the model parameters.</p></li>
<li><p><strong>loaded_scheduler</strong> – Learning rate scheduler.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>The value of the loss or objective function after the training update.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>float</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-anvil.utils">
<span id="anvil-utils-module"></span><h2>anvil.utils module<a class="headerlink" href="#module-anvil.utils" title="Permalink to this headline">¶</a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="anvil.utils.Multiprocessing">
<em class="property"><span class="pre">class</span> </em><span class="sig-prename descclassname"><span class="pre">anvil.utils.</span></span><span class="sig-name descname"><span class="pre">Multiprocessing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">generator</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_multiprocessing</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.utils.Multiprocessing" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Class which implements multiprocessing of a function given a number
inputs for that function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> – the function to be executed multiple times</p></li>
<li><p><strong>generator</strong> – something which, when called, returns a generator object that contains
the parameters for the function.</p></li>
<li><p><strong>use_multiprocessing</strong> (<em>bool</em>) – </p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Does not rely on multiprocessing.Pool since that does not work with
instance methods without considerable extra effort (it cannot pickle them).
This means that the multiprocessing is not supported on Mac.</p>
<dl class="py method">
<dt class="sig sig-object py" id="anvil.utils.Multiprocessing.__call__">
<span class="sig-name descname"><span class="pre">__call__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#anvil.utils.Multiprocessing.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a dictionary containing the function outputs for each
set of parameters taken from the generator. The dictionary keys are
integers which label the order of parameter sets in the generator.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>dict</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="anvil.utils.Multiprocessing.target">
<span class="sig-name descname"><span class="pre">target</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">output_dict</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.utils.Multiprocessing.target" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to be executed for each process.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>k</strong> (<em>int</em>) – </p></li>
<li><p><strong>output_dict</strong> (<em>dict</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>None</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.utils.bootstrap_sample">
<span class="sig-prename descclassname"><span class="pre">anvil.utils.</span></span><span class="sig-name descname"><span class="pre">bootstrap_sample</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bootstrap_sample_size</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.utils.bootstrap_sample" title="Permalink to this definition">¶</a></dt>
<dd><p>Resample a provided array to generate a bootstrap sample.</p>
<p>The last dimension of the array will be one that is bootstrapped, and each
member of the bootstrap sample will have the same shape: <code class="docutils literal notranslate"><span class="pre">data.shape</span></code> .</p>
<p>The boostrap dimension will be inserted at position <code class="docutils literal notranslate"><span class="pre">[-2]</span></code> in the output
array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>numpy.ndarray</em>) – Array containing the data to be resampled.</p></li>
<li><p><strong>bootstrap_sample_size</strong> (<em>int</em>) – Size of the bootstrap sample, i.e. number of times to resample the data.</p></li>
<li><p><strong>seed</strong> – Optional seed for the rng which generates the bootstrap indices, for
reproducibility purposes and to allow different terms in a single
expression to be passed to this function independently.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>Array containing the bootstrap sample, dimensions
<code class="docutils literal notranslate"><span class="pre">(*data.shape[:-1],</span> <span class="pre">bootstrap_sample_size,</span> <span class="pre">data.shape[-1])</span></code> .</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>np.ndarray</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.utils.get_num_parameters">
<span class="sig-prename descclassname"><span class="pre">anvil.utils.</span></span><span class="sig-name descname"><span class="pre">get_num_parameters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">model</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.utils.get_num_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the number of trainable parameters in a model.</p>
<p>Reference: github.com/bayesiains/nflows</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="anvil.utils.handler">
<span class="sig-prename descclassname"><span class="pre">anvil.utils.</span></span><span class="sig-name descname"><span class="pre">handler</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">signum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#anvil.utils.handler" title="Permalink to this definition">¶</a></dt>
<dd><p>Handles keyboard interruptions and terminations and exits in such a way that,
if the program is currently inside a try-except-finally block, the finally clause
will be executed.</p>
<dl class="field-list simple">
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>None</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-anvil">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-anvil" title="Permalink to this headline">¶</a></h2>
</section>
</section>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#">anvil package</a><ul>
<li><a class="reference internal" href="#subpackages">Subpackages</a></li>
<li><a class="reference internal" href="#submodules">Submodules</a></li>
<li><a class="reference internal" href="#module-anvil.api">anvil.api module</a><ul>
<li><a class="reference internal" href="#example">Example:</a></li>
</ul>
</li>
<li><a class="reference internal" href="#module-anvil.benchmarks">anvil.benchmarks module</a></li>
<li><a class="reference internal" href="#module-anvil.checkpoint">anvil.checkpoint module</a></li>
<li><a class="reference internal" href="#module-anvil.checks">anvil.checks module</a></li>
<li><a class="reference internal" href="#module-anvil.config">anvil.config module</a></li>
<li><a class="reference internal" href="#module-anvil.distributions">anvil.distributions module</a></li>
<li><a class="reference internal" href="#module-anvil.free_scalar">anvil.free_scalar module</a></li>
<li><a class="reference internal" href="#module-anvil.geometry">anvil.geometry module</a></li>
<li><a class="reference internal" href="#module-anvil.layers">anvil.layers module</a></li>
<li><a class="reference internal" href="#module-anvil.models">anvil.models module</a></li>
<li><a class="reference internal" href="#module-anvil.neural_network">anvil.neural_network module</a></li>
<li><a class="reference internal" href="#module-anvil.observables">anvil.observables module</a></li>
<li><a class="reference internal" href="#module-anvil.plot">anvil.plot module</a></li>
<li><a class="reference internal" href="#module-anvil.sample">anvil.sample module</a></li>
<li><a class="reference internal" href="#module-anvil.table">anvil.table module</a></li>
<li><a class="reference internal" href="#module-anvil.train">anvil.train module</a></li>
<li><a class="reference internal" href="#module-anvil.utils">anvil.utils module</a></li>
<li><a class="reference internal" href="#module-anvil">Module contents</a></li>
</ul>
</li>
</ul>

  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../../_sources/modules/anvil/anvil.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="nav-item nav-item-0"><a href="../../index.html">anvil  documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">anvil package</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2021, Michael Wilson, Joe Marsh Rossney and Luigi Del Debbio.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 4.0.2.
    </div>
  </body>
</html>